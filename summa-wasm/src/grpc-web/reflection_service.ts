// @generated by protobuf-ts 2.9.1 with parameter long_type_string,use_proto_field_name
// @generated from protobuf file "reflection_service.proto" (package "summa.proto", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// Requests

/**
 * @generated from protobuf message summa.proto.GetTopTermsRequest
 */
export interface GetTopTermsRequest {
    /**
     * @generated from protobuf field: string index_name = 1;
     */
    index_name: string;
    /**
     * @generated from protobuf field: string field_name = 2;
     */
    field_name: string;
    /**
     * @generated from protobuf field: uint32 top_k = 3;
     */
    top_k: number;
}
// Extra structures

/**
 * @generated from protobuf message summa.proto.GetTopTermsResponse
 */
export interface GetTopTermsResponse {
    /**
     * @generated from protobuf field: map<string, summa.proto.SegmentTerms> per_segment = 1;
     */
    per_segment: {
        [key: string]: SegmentTerms;
    };
}
/**
 * @generated from protobuf message summa.proto.SegmentTerms
 */
export interface SegmentTerms {
    /**
     * @generated from protobuf field: repeated summa.proto.TermInfo term_infos = 1;
     */
    term_infos: TermInfo[];
}
/**
 * @generated from protobuf message summa.proto.TermInfo
 */
export interface TermInfo {
    /**
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
    /**
     * @generated from protobuf field: uint32 doc_freq = 2;
     */
    doc_freq: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class GetTopTermsRequest$Type extends MessageType<GetTopTermsRequest> {
    constructor() {
        super("summa.proto.GetTopTermsRequest", [
            { no: 1, name: "index_name", kind: "scalar", localName: "index_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "field_name", kind: "scalar", localName: "field_name", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "top_k", kind: "scalar", localName: "top_k", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetTopTermsRequest>): GetTopTermsRequest {
        const message = { index_name: "", field_name: "", top_k: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetTopTermsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTopTermsRequest): GetTopTermsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string index_name */ 1:
                    message.index_name = reader.string();
                    break;
                case /* string field_name */ 2:
                    message.field_name = reader.string();
                    break;
                case /* uint32 top_k */ 3:
                    message.top_k = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTopTermsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string index_name = 1; */
        if (message.index_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.index_name);
        /* string field_name = 2; */
        if (message.field_name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.field_name);
        /* uint32 top_k = 3; */
        if (message.top_k !== 0)
            writer.tag(3, WireType.Varint).uint32(message.top_k);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.GetTopTermsRequest
 */
export const GetTopTermsRequest = new GetTopTermsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTopTermsResponse$Type extends MessageType<GetTopTermsResponse> {
    constructor() {
        super("summa.proto.GetTopTermsResponse", [
            { no: 1, name: "per_segment", kind: "map", localName: "per_segment", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => SegmentTerms } }
        ]);
    }
    create(value?: PartialMessage<GetTopTermsResponse>): GetTopTermsResponse {
        const message = { per_segment: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetTopTermsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTopTermsResponse): GetTopTermsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, summa.proto.SegmentTerms> per_segment */ 1:
                    this.binaryReadMap1(message.per_segment, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetTopTermsResponse["per_segment"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetTopTermsResponse["per_segment"] | undefined, val: GetTopTermsResponse["per_segment"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = SegmentTerms.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field summa.proto.GetTopTermsResponse.per_segment");
            }
        }
        map[key ?? ""] = val ?? SegmentTerms.create();
    }
    internalBinaryWrite(message: GetTopTermsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, summa.proto.SegmentTerms> per_segment = 1; */
        for (let k of Object.keys(message.per_segment)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            SegmentTerms.internalBinaryWrite(message.per_segment[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.GetTopTermsResponse
 */
export const GetTopTermsResponse = new GetTopTermsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SegmentTerms$Type extends MessageType<SegmentTerms> {
    constructor() {
        super("summa.proto.SegmentTerms", [
            { no: 1, name: "term_infos", kind: "message", localName: "term_infos", repeat: 1 /*RepeatType.PACKED*/, T: () => TermInfo }
        ]);
    }
    create(value?: PartialMessage<SegmentTerms>): SegmentTerms {
        const message = { term_infos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SegmentTerms>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SegmentTerms): SegmentTerms {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated summa.proto.TermInfo term_infos */ 1:
                    message.term_infos.push(TermInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SegmentTerms, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated summa.proto.TermInfo term_infos = 1; */
        for (let i = 0; i < message.term_infos.length; i++)
            TermInfo.internalBinaryWrite(message.term_infos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.SegmentTerms
 */
export const SegmentTerms = new SegmentTerms$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TermInfo$Type extends MessageType<TermInfo> {
    constructor() {
        super("summa.proto.TermInfo", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "doc_freq", kind: "scalar", localName: "doc_freq", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TermInfo>): TermInfo {
        const message = { key: new Uint8Array(0), doc_freq: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TermInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TermInfo): TermInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                case /* uint32 doc_freq */ 2:
                    message.doc_freq = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TermInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        /* uint32 doc_freq = 2; */
        if (message.doc_freq !== 0)
            writer.tag(2, WireType.Varint).uint32(message.doc_freq);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.TermInfo
 */
export const TermInfo = new TermInfo$Type();
/**
 * @generated ServiceType for protobuf service summa.proto.ReflectionApi
 */
export const ReflectionApi = new ServiceType("summa.proto.ReflectionApi", [
    { name: "get_top_terms", options: {}, I: GetTopTermsRequest, O: GetTopTermsResponse }
]);
