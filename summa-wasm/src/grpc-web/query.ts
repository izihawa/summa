// @generated by protobuf-ts 2.9.1 with parameter use_proto_field_name
// @generated from protobuf file "query.proto" (package "summa.proto", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message summa.proto.TermFieldMapperConfig
 */
export interface TermFieldMapperConfig {
    /**
     * @generated from protobuf field: repeated string fields = 1;
     */
    fields: string[];
}
/**
 * @generated from protobuf message summa.proto.MatchQueryBooleanShouldMode
 */
export interface MatchQueryBooleanShouldMode {
}
/**
 * @generated from protobuf message summa.proto.MatchQueryDisjuctionMaxMode
 */
export interface MatchQueryDisjuctionMaxMode {
    /**
     * @generated from protobuf field: float tie_breaker = 1;
     */
    tie_breaker: number;
}
/**
 * @generated from protobuf message summa.proto.ExactMatchesPromoter
 */
export interface ExactMatchesPromoter {
    /**
     * @generated from protobuf field: uint32 slop = 1;
     */
    slop: number;
    /**
     * @generated from protobuf field: optional float boost = 2;
     */
    boost?: number;
    /**
     * @generated from protobuf field: repeated string fields = 3;
     */
    fields: string[];
}
/**
 * @generated from protobuf message summa.proto.NerMatchesPromoter
 */
export interface NerMatchesPromoter {
    /**
     * @generated from protobuf field: optional float boost = 1;
     */
    boost?: number;
    /**
     * @generated from protobuf field: repeated string fields = 2;
     */
    fields: string[];
}
/**
 * @generated from protobuf message summa.proto.MorphologyConfig
 */
export interface MorphologyConfig {
    /**
     * @generated from protobuf field: optional float derive_tenses_coefficient = 1;
     */
    derive_tenses_coefficient?: number;
}
/**
 * @generated from protobuf message summa.proto.QueryParserConfig
 */
export interface QueryParserConfig {
    /**
     * @generated from protobuf field: map<string, string> field_aliases = 1;
     */
    field_aliases: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<string, float> field_boosts = 2;
     */
    field_boosts: {
        [key: string]: number;
    };
    /**
     * @generated from protobuf field: map<string, summa.proto.TermFieldMapperConfig> term_field_mapper_configs = 3;
     */
    term_field_mapper_configs: {
        [key: string]: TermFieldMapperConfig;
    };
    /**
     * @generated from protobuf field: uint32 term_limit = 4;
     */
    term_limit: number;
    /**
     * @generated from protobuf field: repeated string default_fields = 5;
     */
    default_fields: string[];
    /**
     * @generated from protobuf oneof: default_mode
     */
    default_mode: {
        oneofKind: "boolean_should_mode";
        /**
         * @generated from protobuf field: summa.proto.MatchQueryBooleanShouldMode boolean_should_mode = 6;
         */
        boolean_should_mode: MatchQueryBooleanShouldMode;
    } | {
        oneofKind: "disjuction_max_mode";
        /**
         * @generated from protobuf field: summa.proto.MatchQueryDisjuctionMaxMode disjuction_max_mode = 7;
         */
        disjuction_max_mode: MatchQueryDisjuctionMaxMode;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: summa.proto.ExactMatchesPromoter exact_matches_promoter = 8;
     */
    exact_matches_promoter?: ExactMatchesPromoter;
    /**
     * @generated from protobuf field: repeated string excluded_fields = 9;
     */
    excluded_fields: string[];
    /**
     * @generated from protobuf field: map<string, summa.proto.MorphologyConfig> morphology_configs = 10;
     */
    morphology_configs: {
        [key: string]: MorphologyConfig;
    };
    /**
     * @generated from protobuf field: optional string query_language = 11;
     */
    query_language?: string;
}
/**
 * @generated from protobuf message summa.proto.SearchRequest
 */
export interface SearchRequest {
    /**
     * The index name or alias
     *
     * @generated from protobuf field: string index_alias = 1;
     */
    index_alias: string;
    /**
     * Query DSL. Use `MatchQuery` to pass a free-form query
     *
     * @generated from protobuf field: summa.proto.Query query = 2;
     */
    query?: Query;
    /**
     * Every collector is responsible of processing and storing documents and/or their derivatives (like counters)
     * to return them to the caller
     *
     * @generated from protobuf field: repeated summa.proto.Collector collectors = 3;
     */
    collectors: Collector[];
    /**
     * Is requiring fieldnorms needed for the query?
     *
     * @generated from protobuf field: optional bool is_fieldnorms_scoring_enabled = 4;
     */
    is_fieldnorms_scoring_enabled?: boolean;
    /**
     * @generated from protobuf field: optional bool load_cache = 5;
     */
    load_cache?: boolean;
    /**
     * @generated from protobuf field: optional bool store_cache = 6;
     */
    store_cache?: boolean;
}
/**
 * @generated from protobuf message summa.proto.SearchResponse
 */
export interface SearchResponse {
    /**
     * Time spent inside of `search` handler
     *
     * @generated from protobuf field: double elapsed_secs = 1;
     */
    elapsed_secs: number;
    /**
     * An array of collector outputs
     *
     * @generated from protobuf field: repeated summa.proto.CollectorOutput collector_outputs = 2;
     */
    collector_outputs: CollectorOutput[];
}
/**
 * Recursive query DSL
 *
 * @generated from protobuf message summa.proto.Query
 */
export interface Query {
    /**
     * @generated from protobuf oneof: query
     */
    query: {
        oneofKind: "boolean";
        /**
         * @generated from protobuf field: summa.proto.BooleanQuery boolean = 1;
         */
        boolean: BooleanQuery;
    } | {
        oneofKind: "match";
        /**
         * @generated from protobuf field: summa.proto.MatchQuery match = 2;
         */
        match: MatchQuery;
    } | {
        oneofKind: "regex";
        /**
         * @generated from protobuf field: summa.proto.RegexQuery regex = 3;
         */
        regex: RegexQuery;
    } | {
        oneofKind: "term";
        /**
         * @generated from protobuf field: summa.proto.TermQuery term = 4;
         */
        term: TermQuery;
    } | {
        oneofKind: "phrase";
        /**
         * @generated from protobuf field: summa.proto.PhraseQuery phrase = 5;
         */
        phrase: PhraseQuery;
    } | {
        oneofKind: "range";
        /**
         * @generated from protobuf field: summa.proto.RangeQuery range = 6;
         */
        range: RangeQuery;
    } | {
        oneofKind: "all";
        /**
         * @generated from protobuf field: summa.proto.AllQuery all = 7;
         */
        all: AllQuery;
    } | {
        oneofKind: "more_like_this";
        /**
         * @generated from protobuf field: summa.proto.MoreLikeThisQuery more_like_this = 8;
         */
        more_like_this: MoreLikeThisQuery;
    } | {
        oneofKind: "boost";
        /**
         * @generated from protobuf field: summa.proto.BoostQuery boost = 9;
         */
        boost: BoostQuery;
    } | {
        oneofKind: "disjunction_max";
        /**
         * @generated from protobuf field: summa.proto.DisjunctionMaxQuery disjunction_max = 10;
         */
        disjunction_max: DisjunctionMaxQuery;
    } | {
        oneofKind: "empty";
        /**
         * @generated from protobuf field: summa.proto.EmptyQuery empty = 11;
         */
        empty: EmptyQuery;
    } | {
        oneofKind: "exists";
        /**
         * @generated from protobuf field: summa.proto.ExistsQuery exists = 12;
         */
        exists: ExistsQuery;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message summa.proto.AllQuery
 */
export interface AllQuery {
}
/**
 * @generated from protobuf message summa.proto.EmptyQuery
 */
export interface EmptyQuery {
}
/**
 * @generated from protobuf message summa.proto.BoostQuery
 */
export interface BoostQuery {
    /**
     * @generated from protobuf field: summa.proto.Query query = 1;
     */
    query?: Query;
    /**
     * @generated from protobuf field: string score = 2;
     */
    score: string;
}
/**
 * @generated from protobuf message summa.proto.DisjunctionMaxQuery
 */
export interface DisjunctionMaxQuery {
    /**
     * @generated from protobuf field: repeated summa.proto.Query disjuncts = 1;
     */
    disjuncts: Query[];
    /**
     * @generated from protobuf field: string tie_breaker = 2;
     */
    tie_breaker: string;
}
/**
 * @generated from protobuf message summa.proto.MoreLikeThisQuery
 */
export interface MoreLikeThisQuery {
    /**
     * @generated from protobuf field: string document = 1;
     */
    document: string;
    /**
     * @generated from protobuf field: optional uint64 min_doc_frequency = 2;
     */
    min_doc_frequency?: bigint;
    /**
     * @generated from protobuf field: optional uint64 max_doc_frequency = 3;
     */
    max_doc_frequency?: bigint;
    /**
     * @generated from protobuf field: optional uint64 min_term_frequency = 4;
     */
    min_term_frequency?: bigint;
    /**
     * @generated from protobuf field: optional uint64 max_query_terms = 5;
     */
    max_query_terms?: bigint;
    /**
     * @generated from protobuf field: optional uint64 min_word_length = 6;
     */
    min_word_length?: bigint;
    /**
     * @generated from protobuf field: optional uint64 max_word_length = 7;
     */
    max_word_length?: bigint;
    /**
     * @generated from protobuf field: optional string boost = 8;
     */
    boost?: string;
    /**
     * @generated from protobuf field: repeated string stop_words = 9;
     */
    stop_words: string[];
}
/**
 * @generated from protobuf message summa.proto.PhraseQuery
 */
export interface PhraseQuery {
    /**
     * @generated from protobuf field: string field = 1;
     */
    field: string;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
    /**
     * @generated from protobuf field: uint32 slop = 3;
     */
    slop: number;
}
/**
 * @generated from protobuf message summa.proto.RangeQuery
 */
export interface RangeQuery {
    /**
     * @generated from protobuf field: string field = 1;
     */
    field: string;
    /**
     * @generated from protobuf field: summa.proto.Range value = 2;
     */
    value?: Range;
}
/**
 * @generated from protobuf message summa.proto.MatchQuery
 */
export interface MatchQuery {
    /**
     * @generated from protobuf field: string value = 1;
     */
    value: string;
    /**
     * @generated from protobuf field: optional summa.proto.QueryParserConfig query_parser_config = 2;
     */
    query_parser_config?: QueryParserConfig;
}
/**
 * @generated from protobuf message summa.proto.BooleanSubquery
 */
export interface BooleanSubquery {
    /**
     * @generated from protobuf field: summa.proto.Occur occur = 1;
     */
    occur: Occur;
    /**
     * @generated from protobuf field: summa.proto.Query query = 2;
     */
    query?: Query;
}
/**
 * @generated from protobuf message summa.proto.BooleanQuery
 */
export interface BooleanQuery {
    /**
     * @generated from protobuf field: repeated summa.proto.BooleanSubquery subqueries = 1;
     */
    subqueries: BooleanSubquery[];
}
/**
 * @generated from protobuf message summa.proto.RegexQuery
 */
export interface RegexQuery {
    /**
     * @generated from protobuf field: string field = 1;
     */
    field: string;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * @generated from protobuf message summa.proto.TermQuery
 */
export interface TermQuery {
    /**
     * @generated from protobuf field: string field = 1;
     */
    field: string;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * @generated from protobuf message summa.proto.ExistsQuery
 */
export interface ExistsQuery {
    /**
     * @generated from protobuf field: string field = 1;
     */
    field: string;
}
/**
 * @generated from protobuf message summa.proto.Range
 */
export interface Range {
    /**
     * @generated from protobuf field: string left = 1;
     */
    left: string;
    /**
     * @generated from protobuf field: string right = 2;
     */
    right: string;
    /**
     * @generated from protobuf field: bool including_left = 3;
     */
    including_left: boolean;
    /**
     * @generated from protobuf field: bool including_right = 4;
     */
    including_right: boolean;
}
/**
 * @generated from protobuf message summa.proto.Score
 */
export interface Score {
    /**
     * @generated from protobuf oneof: score
     */
    score: {
        oneofKind: "f64_score";
        /**
         * @generated from protobuf field: double f64_score = 1;
         */
        f64_score: number;
    } | {
        oneofKind: "u64_score";
        /**
         * @generated from protobuf field: uint64 u64_score = 2;
         */
        u64_score: bigint;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message summa.proto.Highlight
 */
export interface Highlight {
    /**
     * @generated from protobuf field: uint32 from = 1;
     */
    from: number;
    /**
     * @generated from protobuf field: uint32 to = 2;
     */
    to: number;
}
/**
 * @generated from protobuf message summa.proto.Snippet
 */
export interface Snippet {
    /**
     * @generated from protobuf field: bytes fragment = 1;
     */
    fragment: Uint8Array;
    /**
     * @generated from protobuf field: repeated summa.proto.Highlight highlights = 2;
     */
    highlights: Highlight[];
    /**
     * @generated from protobuf field: string html = 3;
     */
    html: string;
}
/**
 * @generated from protobuf message summa.proto.ScoredDocument
 */
export interface ScoredDocument {
    /**
     * @generated from protobuf field: string document = 1;
     */
    document: string;
    /**
     * @generated from protobuf field: summa.proto.Score score = 2;
     */
    score?: Score;
    /**
     * @generated from protobuf field: uint32 position = 3;
     */
    position: number;
    /**
     * @generated from protobuf field: map<string, summa.proto.Snippet> snippets = 4;
     */
    snippets: {
        [key: string]: Snippet;
    };
    /**
     * @generated from protobuf field: string index_alias = 5;
     */
    index_alias: string;
}
/**
 * @generated from protobuf message summa.proto.Scorer
 */
export interface Scorer {
    /**
     * @generated from protobuf oneof: scorer
     */
    scorer: {
        oneofKind: "eval_expr";
        /**
         * @generated from protobuf field: string eval_expr = 1;
         */
        eval_expr: string;
    } | {
        oneofKind: "order_by";
        /**
         * @generated from protobuf field: string order_by = 2;
         */
        order_by: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Collectors and CollectorOutputs
 *
 * @generated from protobuf message summa.proto.Collector
 */
export interface Collector {
    /**
     * @generated from protobuf oneof: collector
     */
    collector: {
        oneofKind: "top_docs";
        /**
         * @generated from protobuf field: summa.proto.TopDocsCollector top_docs = 1;
         */
        top_docs: TopDocsCollector;
    } | {
        oneofKind: "reservoir_sampling";
        /**
         * @generated from protobuf field: summa.proto.ReservoirSamplingCollector reservoir_sampling = 2;
         */
        reservoir_sampling: ReservoirSamplingCollector;
    } | {
        oneofKind: "count";
        /**
         * @generated from protobuf field: summa.proto.CountCollector count = 3;
         */
        count: CountCollector;
    } | {
        oneofKind: "facet";
        /**
         * @generated from protobuf field: summa.proto.FacetCollector facet = 4;
         */
        facet: FacetCollector;
    } | {
        oneofKind: "aggregation";
        /**
         * @generated from protobuf field: summa.proto.AggregationCollector aggregation = 5;
         */
        aggregation: AggregationCollector;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message summa.proto.CollectorOutput
 */
export interface CollectorOutput {
    /**
     * @generated from protobuf oneof: collector_output
     */
    collector_output: {
        oneofKind: "documents";
        /**
         * @generated from protobuf field: summa.proto.DocumentsCollectorOutput documents = 1;
         */
        documents: DocumentsCollectorOutput;
    } | {
        oneofKind: "count";
        /**
         * @generated from protobuf field: summa.proto.CountCollectorOutput count = 3;
         */
        count: CountCollectorOutput;
    } | {
        oneofKind: "facet";
        /**
         * @generated from protobuf field: summa.proto.FacetCollectorOutput facet = 4;
         */
        facet: FacetCollectorOutput;
    } | {
        oneofKind: "aggregation";
        /**
         * @generated from protobuf field: summa.proto.AggregationCollectorOutput aggregation = 5;
         */
        aggregation: AggregationCollectorOutput;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message summa.proto.CountCollector
 */
export interface CountCollector {
}
/**
 * @generated from protobuf message summa.proto.CountCollectorOutput
 */
export interface CountCollectorOutput {
    /**
     * @generated from protobuf field: uint32 count = 1;
     */
    count: number;
}
/**
 * @generated from protobuf message summa.proto.FacetCollector
 */
export interface FacetCollector {
    /**
     * @generated from protobuf field: string field = 1;
     */
    field: string;
    /**
     * @generated from protobuf field: repeated string facets = 2;
     */
    facets: string[];
}
/**
 * @generated from protobuf message summa.proto.FacetCollectorOutput
 */
export interface FacetCollectorOutput {
    /**
     * @generated from protobuf field: map<string, uint64> facet_counts = 1;
     */
    facet_counts: {
        [key: string]: bigint;
    };
}
/**
 * @generated from protobuf message summa.proto.ReservoirSamplingCollector
 */
export interface ReservoirSamplingCollector {
    /**
     * @generated from protobuf field: uint32 limit = 1;
     */
    limit: number;
    /**
     * @generated from protobuf field: repeated string fields = 2;
     */
    fields: string[];
    /**
     * @generated from protobuf field: repeated string excluded_fields = 3;
     */
    excluded_fields: string[];
}
/**
 * @generated from protobuf message summa.proto.RandomDocument
 */
export interface RandomDocument {
    /**
     * @generated from protobuf field: string document = 1;
     */
    document: string;
    /**
     * @generated from protobuf field: summa.proto.Score score = 2;
     */
    score?: Score;
    /**
     * @generated from protobuf field: string index_alias = 3;
     */
    index_alias: string;
}
/**
 * @generated from protobuf message summa.proto.ReservoirSamplingCollectorOutput
 */
export interface ReservoirSamplingCollectorOutput {
    /**
     * @generated from protobuf field: repeated summa.proto.RandomDocument documents = 1;
     */
    documents: RandomDocument[];
}
/**
 * @generated from protobuf message summa.proto.TopDocsCollector
 */
export interface TopDocsCollector {
    /**
     * @generated from protobuf field: uint32 limit = 1;
     */
    limit: number;
    /**
     * @generated from protobuf field: uint32 offset = 2;
     */
    offset: number;
    /**
     * @generated from protobuf field: optional summa.proto.Scorer scorer = 3;
     */
    scorer?: Scorer;
    /**
     * @generated from protobuf field: map<string, uint32> snippet_configs = 4;
     */
    snippet_configs: {
        [key: string]: number;
    };
    /**
     * @generated from protobuf field: bool explain = 5;
     */
    explain: boolean;
    /**
     * @generated from protobuf field: repeated string fields = 6;
     */
    fields: string[];
    /**
     * @generated from protobuf field: repeated string removed_fields = 7;
     */
    removed_fields: string[];
}
/**
 * @generated from protobuf message summa.proto.DocumentsCollectorOutput
 */
export interface DocumentsCollectorOutput {
    /**
     * @generated from protobuf field: repeated summa.proto.ScoredDocument scored_documents = 1;
     */
    scored_documents: ScoredDocument[];
    /**
     * @generated from protobuf field: bool has_next = 2;
     */
    has_next: boolean;
}
/**
 * @generated from protobuf message summa.proto.AggregationCollector
 */
export interface AggregationCollector {
    /**
     * @generated from protobuf field: string aggregations = 1;
     */
    aggregations: string;
}
/**
 * @generated from protobuf message summa.proto.AggregationCollectorOutput
 */
export interface AggregationCollectorOutput {
    /**
     * @generated from protobuf field: string aggregation_results = 1;
     */
    aggregation_results: string;
}
/**
 * @generated from protobuf enum summa.proto.Occur
 */
export enum Occur {
    /**
     * @generated from protobuf enum value: should = 0;
     */
    should = 0,
    /**
     * @generated from protobuf enum value: must = 1;
     */
    must = 1,
    /**
     * @generated from protobuf enum value: must_not = 2;
     */
    must_not = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class TermFieldMapperConfig$Type extends MessageType<TermFieldMapperConfig> {
    constructor() {
        super("summa.proto.TermFieldMapperConfig", [
            { no: 1, name: "fields", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TermFieldMapperConfig>): TermFieldMapperConfig {
        const message = { fields: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TermFieldMapperConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TermFieldMapperConfig): TermFieldMapperConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string fields */ 1:
                    message.fields.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TermFieldMapperConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string fields = 1; */
        for (let i = 0; i < message.fields.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.fields[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.TermFieldMapperConfig
 */
export const TermFieldMapperConfig = new TermFieldMapperConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MatchQueryBooleanShouldMode$Type extends MessageType<MatchQueryBooleanShouldMode> {
    constructor() {
        super("summa.proto.MatchQueryBooleanShouldMode", []);
    }
    create(value?: PartialMessage<MatchQueryBooleanShouldMode>): MatchQueryBooleanShouldMode {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MatchQueryBooleanShouldMode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MatchQueryBooleanShouldMode): MatchQueryBooleanShouldMode {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MatchQueryBooleanShouldMode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.MatchQueryBooleanShouldMode
 */
export const MatchQueryBooleanShouldMode = new MatchQueryBooleanShouldMode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MatchQueryDisjuctionMaxMode$Type extends MessageType<MatchQueryDisjuctionMaxMode> {
    constructor() {
        super("summa.proto.MatchQueryDisjuctionMaxMode", [
            { no: 1, name: "tie_breaker", kind: "scalar", localName: "tie_breaker", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<MatchQueryDisjuctionMaxMode>): MatchQueryDisjuctionMaxMode {
        const message = { tie_breaker: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MatchQueryDisjuctionMaxMode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MatchQueryDisjuctionMaxMode): MatchQueryDisjuctionMaxMode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float tie_breaker */ 1:
                    message.tie_breaker = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MatchQueryDisjuctionMaxMode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float tie_breaker = 1; */
        if (message.tie_breaker !== 0)
            writer.tag(1, WireType.Bit32).float(message.tie_breaker);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.MatchQueryDisjuctionMaxMode
 */
export const MatchQueryDisjuctionMaxMode = new MatchQueryDisjuctionMaxMode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExactMatchesPromoter$Type extends MessageType<ExactMatchesPromoter> {
    constructor() {
        super("summa.proto.ExactMatchesPromoter", [
            { no: 1, name: "slop", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "boost", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "fields", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExactMatchesPromoter>): ExactMatchesPromoter {
        const message = { slop: 0, fields: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExactMatchesPromoter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExactMatchesPromoter): ExactMatchesPromoter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 slop */ 1:
                    message.slop = reader.uint32();
                    break;
                case /* optional float boost */ 2:
                    message.boost = reader.float();
                    break;
                case /* repeated string fields */ 3:
                    message.fields.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExactMatchesPromoter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 slop = 1; */
        if (message.slop !== 0)
            writer.tag(1, WireType.Varint).uint32(message.slop);
        /* optional float boost = 2; */
        if (message.boost !== undefined)
            writer.tag(2, WireType.Bit32).float(message.boost);
        /* repeated string fields = 3; */
        for (let i = 0; i < message.fields.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.fields[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.ExactMatchesPromoter
 */
export const ExactMatchesPromoter = new ExactMatchesPromoter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NerMatchesPromoter$Type extends MessageType<NerMatchesPromoter> {
    constructor() {
        super("summa.proto.NerMatchesPromoter", [
            { no: 1, name: "boost", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "fields", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<NerMatchesPromoter>): NerMatchesPromoter {
        const message = { fields: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NerMatchesPromoter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NerMatchesPromoter): NerMatchesPromoter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float boost */ 1:
                    message.boost = reader.float();
                    break;
                case /* repeated string fields */ 2:
                    message.fields.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NerMatchesPromoter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float boost = 1; */
        if (message.boost !== undefined)
            writer.tag(1, WireType.Bit32).float(message.boost);
        /* repeated string fields = 2; */
        for (let i = 0; i < message.fields.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.fields[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.NerMatchesPromoter
 */
export const NerMatchesPromoter = new NerMatchesPromoter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MorphologyConfig$Type extends MessageType<MorphologyConfig> {
    constructor() {
        super("summa.proto.MorphologyConfig", [
            { no: 1, name: "derive_tenses_coefficient", kind: "scalar", localName: "derive_tenses_coefficient", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<MorphologyConfig>): MorphologyConfig {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MorphologyConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MorphologyConfig): MorphologyConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float derive_tenses_coefficient */ 1:
                    message.derive_tenses_coefficient = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MorphologyConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float derive_tenses_coefficient = 1; */
        if (message.derive_tenses_coefficient !== undefined)
            writer.tag(1, WireType.Bit32).float(message.derive_tenses_coefficient);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.MorphologyConfig
 */
export const MorphologyConfig = new MorphologyConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryParserConfig$Type extends MessageType<QueryParserConfig> {
    constructor() {
        super("summa.proto.QueryParserConfig", [
            { no: 1, name: "field_aliases", kind: "map", localName: "field_aliases", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 2, name: "field_boosts", kind: "map", localName: "field_boosts", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } },
            { no: 3, name: "term_field_mapper_configs", kind: "map", localName: "term_field_mapper_configs", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => TermFieldMapperConfig } },
            { no: 4, name: "term_limit", kind: "scalar", localName: "term_limit", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "default_fields", kind: "scalar", localName: "default_fields", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "boolean_should_mode", kind: "message", localName: "boolean_should_mode", oneof: "default_mode", T: () => MatchQueryBooleanShouldMode },
            { no: 7, name: "disjuction_max_mode", kind: "message", localName: "disjuction_max_mode", oneof: "default_mode", T: () => MatchQueryDisjuctionMaxMode },
            { no: 8, name: "exact_matches_promoter", kind: "message", localName: "exact_matches_promoter", T: () => ExactMatchesPromoter },
            { no: 9, name: "removed_fields", kind: "scalar", localName: "removed_fields", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "morphology_configs", kind: "map", localName: "morphology_configs", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => MorphologyConfig } },
            { no: 11, name: "query_language", kind: "scalar", localName: "query_language", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryParserConfig>): QueryParserConfig {
        const message = { field_aliases: {}, field_boosts: {}, term_field_mapper_configs: {}, term_limit: 0, default_fields: [], default_mode: { oneofKind: undefined }, removed_fields: [], morphology_configs: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryParserConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryParserConfig): QueryParserConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> field_aliases */ 1:
                    this.binaryReadMap1(message.field_aliases, reader, options);
                    break;
                case /* map<string, float> field_boosts */ 2:
                    this.binaryReadMap2(message.field_boosts, reader, options);
                    break;
                case /* map<string, summa.proto.TermFieldMapperConfig> term_field_mapper_configs */ 3:
                    this.binaryReadMap3(message.term_field_mapper_configs, reader, options);
                    break;
                case /* uint32 term_limit */ 4:
                    message.term_limit = reader.uint32();
                    break;
                case /* repeated string default_fields */ 5:
                    message.default_fields.push(reader.string());
                    break;
                case /* summa.proto.MatchQueryBooleanShouldMode boolean_should_mode */ 6:
                    message.default_mode = {
                        oneofKind: "boolean_should_mode",
                        boolean_should_mode: MatchQueryBooleanShouldMode.internalBinaryRead(reader, reader.uint32(), options, (message.default_mode as any).boolean_should_mode)
                    };
                    break;
                case /* summa.proto.MatchQueryDisjuctionMaxMode disjuction_max_mode */ 7:
                    message.default_mode = {
                        oneofKind: "disjuction_max_mode",
                        disjuction_max_mode: MatchQueryDisjuctionMaxMode.internalBinaryRead(reader, reader.uint32(), options, (message.default_mode as any).disjuction_max_mode)
                    };
                    break;
                case /* summa.proto.ExactMatchesPromoter exact_matches_promoter */ 8:
                    message.exact_matches_promoter = ExactMatchesPromoter.internalBinaryRead(reader, reader.uint32(), options, message.exact_matches_promoter);
                    break;
                case /* repeated string removed_fields */ 9:
                    message.removed_fields.push(reader.string());
                    break;
                case /* map<string, summa.proto.MorphologyConfig> morphology_configs */ 10:
                    this.binaryReadMap10(message.morphology_configs, reader, options);
                    break;
                case /* optional string query_language */ 11:
                    message.query_language = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: QueryParserConfig["field_aliases"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof QueryParserConfig["field_aliases"] | undefined, val: QueryParserConfig["field_aliases"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field summa.proto.QueryParserConfig.field_aliases");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap2(map: QueryParserConfig["field_boosts"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof QueryParserConfig["field_boosts"] | undefined, val: QueryParserConfig["field_boosts"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.float();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field summa.proto.QueryParserConfig.field_boosts");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    private binaryReadMap3(map: QueryParserConfig["term_field_mapper_configs"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof QueryParserConfig["term_field_mapper_configs"] | undefined, val: QueryParserConfig["term_field_mapper_configs"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = TermFieldMapperConfig.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field summa.proto.QueryParserConfig.term_field_mapper_configs");
            }
        }
        map[key ?? ""] = val ?? TermFieldMapperConfig.create();
    }
    private binaryReadMap10(map: QueryParserConfig["morphology_configs"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof QueryParserConfig["morphology_configs"] | undefined, val: QueryParserConfig["morphology_configs"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = MorphologyConfig.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field summa.proto.QueryParserConfig.morphology_configs");
            }
        }
        map[key ?? ""] = val ?? MorphologyConfig.create();
    }
    internalBinaryWrite(message: QueryParserConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> field_aliases = 1; */
        for (let k of Object.keys(message.field_aliases))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.field_aliases[k]).join();
        /* map<string, float> field_boosts = 2; */
        for (let k of Object.keys(message.field_boosts))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Bit32).float(message.field_boosts[k]).join();
        /* map<string, summa.proto.TermFieldMapperConfig> term_field_mapper_configs = 3; */
        for (let k of Object.keys(message.term_field_mapper_configs)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            TermFieldMapperConfig.internalBinaryWrite(message.term_field_mapper_configs[k], writer, options);
            writer.join().join();
        }
        /* uint32 term_limit = 4; */
        if (message.term_limit !== 0)
            writer.tag(4, WireType.Varint).uint32(message.term_limit);
        /* repeated string default_fields = 5; */
        for (let i = 0; i < message.default_fields.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.default_fields[i]);
        /* summa.proto.MatchQueryBooleanShouldMode boolean_should_mode = 6; */
        if (message.default_mode.oneofKind === "boolean_should_mode")
            MatchQueryBooleanShouldMode.internalBinaryWrite(message.default_mode.boolean_should_mode, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.MatchQueryDisjuctionMaxMode disjuction_max_mode = 7; */
        if (message.default_mode.oneofKind === "disjuction_max_mode")
            MatchQueryDisjuctionMaxMode.internalBinaryWrite(message.default_mode.disjuction_max_mode, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.ExactMatchesPromoter exact_matches_promoter = 8; */
        if (message.exact_matches_promoter)
            ExactMatchesPromoter.internalBinaryWrite(message.exact_matches_promoter, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated string removed_fields = 9; */
        for (let i = 0; i < message.removed_fields.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.removed_fields[i]);
        /* map<string, summa.proto.MorphologyConfig> morphology_configs = 10; */
        for (let k of Object.keys(message.morphology_configs)) {
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            MorphologyConfig.internalBinaryWrite(message.morphology_configs[k], writer, options);
            writer.join().join();
        }
        /* optional string query_language = 11; */
        if (message.query_language !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.query_language);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.QueryParserConfig
 */
export const QueryParserConfig = new QueryParserConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SearchRequest$Type extends MessageType<SearchRequest> {
    constructor() {
        super("summa.proto.SearchRequest", [
            { no: 1, name: "index_alias", kind: "scalar", localName: "index_alias", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "query", kind: "message", T: () => Query },
            { no: 3, name: "collectors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Collector },
            { no: 4, name: "is_fieldnorms_scoring_enabled", kind: "scalar", localName: "is_fieldnorms_scoring_enabled", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "load_cache", kind: "scalar", localName: "load_cache", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "store_cache", kind: "scalar", localName: "store_cache", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SearchRequest>): SearchRequest {
        const message = { index_alias: "", collectors: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SearchRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchRequest): SearchRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string index_alias */ 1:
                    message.index_alias = reader.string();
                    break;
                case /* summa.proto.Query query */ 2:
                    message.query = Query.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                case /* repeated summa.proto.Collector collectors */ 3:
                    message.collectors.push(Collector.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool is_fieldnorms_scoring_enabled */ 4:
                    message.is_fieldnorms_scoring_enabled = reader.bool();
                    break;
                case /* optional bool load_cache */ 5:
                    message.load_cache = reader.bool();
                    break;
                case /* optional bool store_cache */ 6:
                    message.store_cache = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SearchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string index_alias = 1; */
        if (message.index_alias !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.index_alias);
        /* summa.proto.Query query = 2; */
        if (message.query)
            Query.internalBinaryWrite(message.query, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated summa.proto.Collector collectors = 3; */
        for (let i = 0; i < message.collectors.length; i++)
            Collector.internalBinaryWrite(message.collectors[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_fieldnorms_scoring_enabled = 4; */
        if (message.is_fieldnorms_scoring_enabled !== undefined)
            writer.tag(4, WireType.Varint).bool(message.is_fieldnorms_scoring_enabled);
        /* optional bool load_cache = 5; */
        if (message.load_cache !== undefined)
            writer.tag(5, WireType.Varint).bool(message.load_cache);
        /* optional bool store_cache = 6; */
        if (message.store_cache !== undefined)
            writer.tag(6, WireType.Varint).bool(message.store_cache);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.SearchRequest
 */
export const SearchRequest = new SearchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SearchResponse$Type extends MessageType<SearchResponse> {
    constructor() {
        super("summa.proto.SearchResponse", [
            { no: 1, name: "elapsed_secs", kind: "scalar", localName: "elapsed_secs", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "collector_outputs", kind: "message", localName: "collector_outputs", repeat: 1 /*RepeatType.PACKED*/, T: () => CollectorOutput }
        ]);
    }
    create(value?: PartialMessage<SearchResponse>): SearchResponse {
        const message = { elapsed_secs: 0, collector_outputs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SearchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchResponse): SearchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double elapsed_secs */ 1:
                    message.elapsed_secs = reader.double();
                    break;
                case /* repeated summa.proto.CollectorOutput collector_outputs */ 2:
                    message.collector_outputs.push(CollectorOutput.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SearchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double elapsed_secs = 1; */
        if (message.elapsed_secs !== 0)
            writer.tag(1, WireType.Bit64).double(message.elapsed_secs);
        /* repeated summa.proto.CollectorOutput collector_outputs = 2; */
        for (let i = 0; i < message.collector_outputs.length; i++)
            CollectorOutput.internalBinaryWrite(message.collector_outputs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.SearchResponse
 */
export const SearchResponse = new SearchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Query$Type extends MessageType<Query> {
    constructor() {
        super("summa.proto.Query", [
            { no: 1, name: "boolean", kind: "message", oneof: "query", T: () => BooleanQuery },
            { no: 2, name: "match", kind: "message", oneof: "query", T: () => MatchQuery },
            { no: 3, name: "regex", kind: "message", oneof: "query", T: () => RegexQuery },
            { no: 4, name: "term", kind: "message", oneof: "query", T: () => TermQuery },
            { no: 5, name: "phrase", kind: "message", oneof: "query", T: () => PhraseQuery },
            { no: 6, name: "range", kind: "message", oneof: "query", T: () => RangeQuery },
            { no: 7, name: "all", kind: "message", oneof: "query", T: () => AllQuery },
            { no: 8, name: "more_like_this", kind: "message", localName: "more_like_this", oneof: "query", T: () => MoreLikeThisQuery },
            { no: 9, name: "boost", kind: "message", oneof: "query", T: () => BoostQuery },
            { no: 10, name: "disjunction_max", kind: "message", localName: "disjunction_max", oneof: "query", T: () => DisjunctionMaxQuery },
            { no: 11, name: "empty", kind: "message", oneof: "query", T: () => EmptyQuery },
            { no: 12, name: "exists", kind: "message", oneof: "query", T: () => ExistsQuery }
        ]);
    }
    create(value?: PartialMessage<Query>): Query {
        const message = { query: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Query>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Query): Query {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* summa.proto.BooleanQuery boolean */ 1:
                    message.query = {
                        oneofKind: "boolean",
                        boolean: BooleanQuery.internalBinaryRead(reader, reader.uint32(), options, (message.query as any).boolean)
                    };
                    break;
                case /* summa.proto.MatchQuery match */ 2:
                    message.query = {
                        oneofKind: "match",
                        match: MatchQuery.internalBinaryRead(reader, reader.uint32(), options, (message.query as any).match)
                    };
                    break;
                case /* summa.proto.RegexQuery regex */ 3:
                    message.query = {
                        oneofKind: "regex",
                        regex: RegexQuery.internalBinaryRead(reader, reader.uint32(), options, (message.query as any).regex)
                    };
                    break;
                case /* summa.proto.TermQuery term */ 4:
                    message.query = {
                        oneofKind: "term",
                        term: TermQuery.internalBinaryRead(reader, reader.uint32(), options, (message.query as any).term)
                    };
                    break;
                case /* summa.proto.PhraseQuery phrase */ 5:
                    message.query = {
                        oneofKind: "phrase",
                        phrase: PhraseQuery.internalBinaryRead(reader, reader.uint32(), options, (message.query as any).phrase)
                    };
                    break;
                case /* summa.proto.RangeQuery range */ 6:
                    message.query = {
                        oneofKind: "range",
                        range: RangeQuery.internalBinaryRead(reader, reader.uint32(), options, (message.query as any).range)
                    };
                    break;
                case /* summa.proto.AllQuery all */ 7:
                    message.query = {
                        oneofKind: "all",
                        all: AllQuery.internalBinaryRead(reader, reader.uint32(), options, (message.query as any).all)
                    };
                    break;
                case /* summa.proto.MoreLikeThisQuery more_like_this */ 8:
                    message.query = {
                        oneofKind: "more_like_this",
                        more_like_this: MoreLikeThisQuery.internalBinaryRead(reader, reader.uint32(), options, (message.query as any).more_like_this)
                    };
                    break;
                case /* summa.proto.BoostQuery boost */ 9:
                    message.query = {
                        oneofKind: "boost",
                        boost: BoostQuery.internalBinaryRead(reader, reader.uint32(), options, (message.query as any).boost)
                    };
                    break;
                case /* summa.proto.DisjunctionMaxQuery disjunction_max */ 10:
                    message.query = {
                        oneofKind: "disjunction_max",
                        disjunction_max: DisjunctionMaxQuery.internalBinaryRead(reader, reader.uint32(), options, (message.query as any).disjunction_max)
                    };
                    break;
                case /* summa.proto.EmptyQuery empty */ 11:
                    message.query = {
                        oneofKind: "empty",
                        empty: EmptyQuery.internalBinaryRead(reader, reader.uint32(), options, (message.query as any).empty)
                    };
                    break;
                case /* summa.proto.ExistsQuery exists */ 12:
                    message.query = {
                        oneofKind: "exists",
                        exists: ExistsQuery.internalBinaryRead(reader, reader.uint32(), options, (message.query as any).exists)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Query, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* summa.proto.BooleanQuery boolean = 1; */
        if (message.query.oneofKind === "boolean")
            BooleanQuery.internalBinaryWrite(message.query.boolean, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.MatchQuery match = 2; */
        if (message.query.oneofKind === "match")
            MatchQuery.internalBinaryWrite(message.query.match, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.RegexQuery regex = 3; */
        if (message.query.oneofKind === "regex")
            RegexQuery.internalBinaryWrite(message.query.regex, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.TermQuery term = 4; */
        if (message.query.oneofKind === "term")
            TermQuery.internalBinaryWrite(message.query.term, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.PhraseQuery phrase = 5; */
        if (message.query.oneofKind === "phrase")
            PhraseQuery.internalBinaryWrite(message.query.phrase, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.RangeQuery range = 6; */
        if (message.query.oneofKind === "range")
            RangeQuery.internalBinaryWrite(message.query.range, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.AllQuery all = 7; */
        if (message.query.oneofKind === "all")
            AllQuery.internalBinaryWrite(message.query.all, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.MoreLikeThisQuery more_like_this = 8; */
        if (message.query.oneofKind === "more_like_this")
            MoreLikeThisQuery.internalBinaryWrite(message.query.more_like_this, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.BoostQuery boost = 9; */
        if (message.query.oneofKind === "boost")
            BoostQuery.internalBinaryWrite(message.query.boost, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.DisjunctionMaxQuery disjunction_max = 10; */
        if (message.query.oneofKind === "disjunction_max")
            DisjunctionMaxQuery.internalBinaryWrite(message.query.disjunction_max, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.EmptyQuery empty = 11; */
        if (message.query.oneofKind === "empty")
            EmptyQuery.internalBinaryWrite(message.query.empty, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.ExistsQuery exists = 12; */
        if (message.query.oneofKind === "exists")
            ExistsQuery.internalBinaryWrite(message.query.exists, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.Query
 */
export const Query = new Query$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AllQuery$Type extends MessageType<AllQuery> {
    constructor() {
        super("summa.proto.AllQuery", []);
    }
    create(value?: PartialMessage<AllQuery>): AllQuery {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AllQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AllQuery): AllQuery {
        return target ?? this.create();
    }
    internalBinaryWrite(message: AllQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.AllQuery
 */
export const AllQuery = new AllQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmptyQuery$Type extends MessageType<EmptyQuery> {
    constructor() {
        super("summa.proto.EmptyQuery", []);
    }
    create(value?: PartialMessage<EmptyQuery>): EmptyQuery {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EmptyQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmptyQuery): EmptyQuery {
        return target ?? this.create();
    }
    internalBinaryWrite(message: EmptyQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.EmptyQuery
 */
export const EmptyQuery = new EmptyQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BoostQuery$Type extends MessageType<BoostQuery> {
    constructor() {
        super("summa.proto.BoostQuery", [
            { no: 1, name: "query", kind: "message", T: () => Query },
            { no: 2, name: "score", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BoostQuery>): BoostQuery {
        const message = { score: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BoostQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BoostQuery): BoostQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* summa.proto.Query query */ 1:
                    message.query = Query.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                case /* string score */ 2:
                    message.score = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BoostQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* summa.proto.Query query = 1; */
        if (message.query)
            Query.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string score = 2; */
        if (message.score !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.score);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.BoostQuery
 */
export const BoostQuery = new BoostQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisjunctionMaxQuery$Type extends MessageType<DisjunctionMaxQuery> {
    constructor() {
        super("summa.proto.DisjunctionMaxQuery", [
            { no: 1, name: "disjuncts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Query },
            { no: 2, name: "tie_breaker", kind: "scalar", localName: "tie_breaker", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DisjunctionMaxQuery>): DisjunctionMaxQuery {
        const message = { disjuncts: [], tie_breaker: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DisjunctionMaxQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DisjunctionMaxQuery): DisjunctionMaxQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated summa.proto.Query disjuncts */ 1:
                    message.disjuncts.push(Query.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string tie_breaker */ 2:
                    message.tie_breaker = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DisjunctionMaxQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated summa.proto.Query disjuncts = 1; */
        for (let i = 0; i < message.disjuncts.length; i++)
            Query.internalBinaryWrite(message.disjuncts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string tie_breaker = 2; */
        if (message.tie_breaker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tie_breaker);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.DisjunctionMaxQuery
 */
export const DisjunctionMaxQuery = new DisjunctionMaxQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoreLikeThisQuery$Type extends MessageType<MoreLikeThisQuery> {
    constructor() {
        super("summa.proto.MoreLikeThisQuery", [
            { no: 1, name: "document", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "min_doc_frequency", kind: "scalar", localName: "min_doc_frequency", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "max_doc_frequency", kind: "scalar", localName: "max_doc_frequency", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "min_term_frequency", kind: "scalar", localName: "min_term_frequency", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "max_query_terms", kind: "scalar", localName: "max_query_terms", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "min_word_length", kind: "scalar", localName: "min_word_length", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "max_word_length", kind: "scalar", localName: "max_word_length", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "boost", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "stop_words", kind: "scalar", localName: "stop_words", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MoreLikeThisQuery>): MoreLikeThisQuery {
        const message = { document: "", stop_words: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MoreLikeThisQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoreLikeThisQuery): MoreLikeThisQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string document */ 1:
                    message.document = reader.string();
                    break;
                case /* optional uint64 min_doc_frequency */ 2:
                    message.min_doc_frequency = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 max_doc_frequency */ 3:
                    message.max_doc_frequency = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 min_term_frequency */ 4:
                    message.min_term_frequency = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 max_query_terms */ 5:
                    message.max_query_terms = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 min_word_length */ 6:
                    message.min_word_length = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 max_word_length */ 7:
                    message.max_word_length = reader.uint64().toBigInt();
                    break;
                case /* optional string boost */ 8:
                    message.boost = reader.string();
                    break;
                case /* repeated string stop_words */ 9:
                    message.stop_words.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoreLikeThisQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string document = 1; */
        if (message.document !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.document);
        /* optional uint64 min_doc_frequency = 2; */
        if (message.min_doc_frequency !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.min_doc_frequency);
        /* optional uint64 max_doc_frequency = 3; */
        if (message.max_doc_frequency !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.max_doc_frequency);
        /* optional uint64 min_term_frequency = 4; */
        if (message.min_term_frequency !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.min_term_frequency);
        /* optional uint64 max_query_terms = 5; */
        if (message.max_query_terms !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.max_query_terms);
        /* optional uint64 min_word_length = 6; */
        if (message.min_word_length !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.min_word_length);
        /* optional uint64 max_word_length = 7; */
        if (message.max_word_length !== undefined)
            writer.tag(7, WireType.Varint).uint64(message.max_word_length);
        /* optional string boost = 8; */
        if (message.boost !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.boost);
        /* repeated string stop_words = 9; */
        for (let i = 0; i < message.stop_words.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.stop_words[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.MoreLikeThisQuery
 */
export const MoreLikeThisQuery = new MoreLikeThisQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PhraseQuery$Type extends MessageType<PhraseQuery> {
    constructor() {
        super("summa.proto.PhraseQuery", [
            { no: 1, name: "field", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "slop", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PhraseQuery>): PhraseQuery {
        const message = { field: "", value: "", slop: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PhraseQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PhraseQuery): PhraseQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string field */ 1:
                    message.field = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                case /* uint32 slop */ 3:
                    message.slop = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PhraseQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string field = 1; */
        if (message.field !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.field);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        /* uint32 slop = 3; */
        if (message.slop !== 0)
            writer.tag(3, WireType.Varint).uint32(message.slop);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.PhraseQuery
 */
export const PhraseQuery = new PhraseQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RangeQuery$Type extends MessageType<RangeQuery> {
    constructor() {
        super("summa.proto.RangeQuery", [
            { no: 1, name: "field", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => Range }
        ]);
    }
    create(value?: PartialMessage<RangeQuery>): RangeQuery {
        const message = { field: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RangeQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RangeQuery): RangeQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string field */ 1:
                    message.field = reader.string();
                    break;
                case /* summa.proto.Range value */ 2:
                    message.value = Range.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RangeQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string field = 1; */
        if (message.field !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.field);
        /* summa.proto.Range value = 2; */
        if (message.value)
            Range.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.RangeQuery
 */
export const RangeQuery = new RangeQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MatchQuery$Type extends MessageType<MatchQuery> {
    constructor() {
        super("summa.proto.MatchQuery", [
            { no: 1, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "query_parser_config", kind: "message", localName: "query_parser_config", T: () => QueryParserConfig }
        ]);
    }
    create(value?: PartialMessage<MatchQuery>): MatchQuery {
        const message = { value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MatchQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MatchQuery): MatchQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string value */ 1:
                    message.value = reader.string();
                    break;
                case /* optional summa.proto.QueryParserConfig query_parser_config */ 2:
                    message.query_parser_config = QueryParserConfig.internalBinaryRead(reader, reader.uint32(), options, message.query_parser_config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MatchQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string value = 1; */
        if (message.value !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.value);
        /* optional summa.proto.QueryParserConfig query_parser_config = 2; */
        if (message.query_parser_config)
            QueryParserConfig.internalBinaryWrite(message.query_parser_config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.MatchQuery
 */
export const MatchQuery = new MatchQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BooleanSubquery$Type extends MessageType<BooleanSubquery> {
    constructor() {
        super("summa.proto.BooleanSubquery", [
            { no: 1, name: "occur", kind: "enum", T: () => ["summa.proto.Occur", Occur] },
            { no: 2, name: "query", kind: "message", T: () => Query }
        ]);
    }
    create(value?: PartialMessage<BooleanSubquery>): BooleanSubquery {
        const message = { occur: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BooleanSubquery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BooleanSubquery): BooleanSubquery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* summa.proto.Occur occur */ 1:
                    message.occur = reader.int32();
                    break;
                case /* summa.proto.Query query */ 2:
                    message.query = Query.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BooleanSubquery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* summa.proto.Occur occur = 1; */
        if (message.occur !== 0)
            writer.tag(1, WireType.Varint).int32(message.occur);
        /* summa.proto.Query query = 2; */
        if (message.query)
            Query.internalBinaryWrite(message.query, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.BooleanSubquery
 */
export const BooleanSubquery = new BooleanSubquery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BooleanQuery$Type extends MessageType<BooleanQuery> {
    constructor() {
        super("summa.proto.BooleanQuery", [
            { no: 1, name: "subqueries", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BooleanSubquery }
        ]);
    }
    create(value?: PartialMessage<BooleanQuery>): BooleanQuery {
        const message = { subqueries: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BooleanQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BooleanQuery): BooleanQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated summa.proto.BooleanSubquery subqueries */ 1:
                    message.subqueries.push(BooleanSubquery.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BooleanQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated summa.proto.BooleanSubquery subqueries = 1; */
        for (let i = 0; i < message.subqueries.length; i++)
            BooleanSubquery.internalBinaryWrite(message.subqueries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.BooleanQuery
 */
export const BooleanQuery = new BooleanQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegexQuery$Type extends MessageType<RegexQuery> {
    constructor() {
        super("summa.proto.RegexQuery", [
            { no: 1, name: "field", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RegexQuery>): RegexQuery {
        const message = { field: "", value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegexQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegexQuery): RegexQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string field */ 1:
                    message.field = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegexQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string field = 1; */
        if (message.field !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.field);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.RegexQuery
 */
export const RegexQuery = new RegexQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TermQuery$Type extends MessageType<TermQuery> {
    constructor() {
        super("summa.proto.TermQuery", [
            { no: 1, name: "field", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TermQuery>): TermQuery {
        const message = { field: "", value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TermQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TermQuery): TermQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string field */ 1:
                    message.field = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TermQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string field = 1; */
        if (message.field !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.field);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.TermQuery
 */
export const TermQuery = new TermQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExistsQuery$Type extends MessageType<ExistsQuery> {
    constructor() {
        super("summa.proto.ExistsQuery", [
            { no: 1, name: "field", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExistsQuery>): ExistsQuery {
        const message = { field: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExistsQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExistsQuery): ExistsQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string field */ 1:
                    message.field = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExistsQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string field = 1; */
        if (message.field !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.field);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.ExistsQuery
 */
export const ExistsQuery = new ExistsQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Range$Type extends MessageType<Range> {
    constructor() {
        super("summa.proto.Range", [
            { no: 1, name: "left", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "right", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "including_left", kind: "scalar", localName: "including_left", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "including_right", kind: "scalar", localName: "including_right", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Range>): Range {
        const message = { left: "", right: "", including_left: false, including_right: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Range>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Range): Range {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string left */ 1:
                    message.left = reader.string();
                    break;
                case /* string right */ 2:
                    message.right = reader.string();
                    break;
                case /* bool including_left */ 3:
                    message.including_left = reader.bool();
                    break;
                case /* bool including_right */ 4:
                    message.including_right = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Range, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string left = 1; */
        if (message.left !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.left);
        /* string right = 2; */
        if (message.right !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.right);
        /* bool including_left = 3; */
        if (message.including_left !== false)
            writer.tag(3, WireType.Varint).bool(message.including_left);
        /* bool including_right = 4; */
        if (message.including_right !== false)
            writer.tag(4, WireType.Varint).bool(message.including_right);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.Range
 */
export const Range = new Range$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Score$Type extends MessageType<Score> {
    constructor() {
        super("summa.proto.Score", [
            { no: 1, name: "f64_score", kind: "scalar", localName: "f64_score", oneof: "score", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "u64_score", kind: "scalar", localName: "u64_score", oneof: "score", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Score>): Score {
        const message = { score: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Score>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Score): Score {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double f64_score */ 1:
                    message.score = {
                        oneofKind: "f64_score",
                        f64_score: reader.double()
                    };
                    break;
                case /* uint64 u64_score */ 2:
                    message.score = {
                        oneofKind: "u64_score",
                        u64_score: reader.uint64().toBigInt()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Score, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double f64_score = 1; */
        if (message.score.oneofKind === "f64_score")
            writer.tag(1, WireType.Bit64).double(message.score.f64_score);
        /* uint64 u64_score = 2; */
        if (message.score.oneofKind === "u64_score")
            writer.tag(2, WireType.Varint).uint64(message.score.u64_score);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.Score
 */
export const Score = new Score$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Highlight$Type extends MessageType<Highlight> {
    constructor() {
        super("summa.proto.Highlight", [
            { no: 1, name: "from", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "to", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Highlight>): Highlight {
        const message = { from: 0, to: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Highlight>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Highlight): Highlight {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 from */ 1:
                    message.from = reader.uint32();
                    break;
                case /* uint32 to */ 2:
                    message.to = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Highlight, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 from = 1; */
        if (message.from !== 0)
            writer.tag(1, WireType.Varint).uint32(message.from);
        /* uint32 to = 2; */
        if (message.to !== 0)
            writer.tag(2, WireType.Varint).uint32(message.to);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.Highlight
 */
export const Highlight = new Highlight$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Snippet$Type extends MessageType<Snippet> {
    constructor() {
        super("summa.proto.Snippet", [
            { no: 1, name: "fragment", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "highlights", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Highlight },
            { no: 3, name: "html", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Snippet>): Snippet {
        const message = { fragment: new Uint8Array(0), highlights: [], html: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Snippet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Snippet): Snippet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes fragment */ 1:
                    message.fragment = reader.bytes();
                    break;
                case /* repeated summa.proto.Highlight highlights */ 2:
                    message.highlights.push(Highlight.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string html */ 3:
                    message.html = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Snippet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes fragment = 1; */
        if (message.fragment.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.fragment);
        /* repeated summa.proto.Highlight highlights = 2; */
        for (let i = 0; i < message.highlights.length; i++)
            Highlight.internalBinaryWrite(message.highlights[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string html = 3; */
        if (message.html !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.html);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.Snippet
 */
export const Snippet = new Snippet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScoredDocument$Type extends MessageType<ScoredDocument> {
    constructor() {
        super("summa.proto.ScoredDocument", [
            { no: 1, name: "document", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "score", kind: "message", T: () => Score },
            { no: 3, name: "position", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "snippets", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Snippet } },
            { no: 5, name: "index_alias", kind: "scalar", localName: "index_alias", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ScoredDocument>): ScoredDocument {
        const message = { document: "", position: 0, snippets: {}, index_alias: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ScoredDocument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScoredDocument): ScoredDocument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string document */ 1:
                    message.document = reader.string();
                    break;
                case /* summa.proto.Score score */ 2:
                    message.score = Score.internalBinaryRead(reader, reader.uint32(), options, message.score);
                    break;
                case /* uint32 position */ 3:
                    message.position = reader.uint32();
                    break;
                case /* map<string, summa.proto.Snippet> snippets */ 4:
                    this.binaryReadMap4(message.snippets, reader, options);
                    break;
                case /* string index_alias */ 5:
                    message.index_alias = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: ScoredDocument["snippets"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ScoredDocument["snippets"] | undefined, val: ScoredDocument["snippets"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Snippet.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field summa.proto.ScoredDocument.snippets");
            }
        }
        map[key ?? ""] = val ?? Snippet.create();
    }
    internalBinaryWrite(message: ScoredDocument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string document = 1; */
        if (message.document !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.document);
        /* summa.proto.Score score = 2; */
        if (message.score)
            Score.internalBinaryWrite(message.score, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 position = 3; */
        if (message.position !== 0)
            writer.tag(3, WireType.Varint).uint32(message.position);
        /* map<string, summa.proto.Snippet> snippets = 4; */
        for (let k of Object.keys(message.snippets)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Snippet.internalBinaryWrite(message.snippets[k], writer, options);
            writer.join().join();
        }
        /* string index_alias = 5; */
        if (message.index_alias !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.index_alias);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.ScoredDocument
 */
export const ScoredDocument = new ScoredDocument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Scorer$Type extends MessageType<Scorer> {
    constructor() {
        super("summa.proto.Scorer", [
            { no: 1, name: "eval_expr", kind: "scalar", localName: "eval_expr", oneof: "scorer", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order_by", kind: "scalar", localName: "order_by", oneof: "scorer", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Scorer>): Scorer {
        const message = { scorer: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Scorer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Scorer): Scorer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string eval_expr */ 1:
                    message.scorer = {
                        oneofKind: "eval_expr",
                        eval_expr: reader.string()
                    };
                    break;
                case /* string order_by */ 2:
                    message.scorer = {
                        oneofKind: "order_by",
                        order_by: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Scorer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string eval_expr = 1; */
        if (message.scorer.oneofKind === "eval_expr")
            writer.tag(1, WireType.LengthDelimited).string(message.scorer.eval_expr);
        /* string order_by = 2; */
        if (message.scorer.oneofKind === "order_by")
            writer.tag(2, WireType.LengthDelimited).string(message.scorer.order_by);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.Scorer
 */
export const Scorer = new Scorer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Collector$Type extends MessageType<Collector> {
    constructor() {
        super("summa.proto.Collector", [
            { no: 1, name: "top_docs", kind: "message", localName: "top_docs", oneof: "collector", T: () => TopDocsCollector },
            { no: 2, name: "reservoir_sampling", kind: "message", localName: "reservoir_sampling", oneof: "collector", T: () => ReservoirSamplingCollector },
            { no: 3, name: "count", kind: "message", oneof: "collector", T: () => CountCollector },
            { no: 4, name: "facet", kind: "message", oneof: "collector", T: () => FacetCollector },
            { no: 5, name: "aggregation", kind: "message", oneof: "collector", T: () => AggregationCollector }
        ]);
    }
    create(value?: PartialMessage<Collector>): Collector {
        const message = { collector: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Collector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Collector): Collector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* summa.proto.TopDocsCollector top_docs */ 1:
                    message.collector = {
                        oneofKind: "top_docs",
                        top_docs: TopDocsCollector.internalBinaryRead(reader, reader.uint32(), options, (message.collector as any).top_docs)
                    };
                    break;
                case /* summa.proto.ReservoirSamplingCollector reservoir_sampling */ 2:
                    message.collector = {
                        oneofKind: "reservoir_sampling",
                        reservoir_sampling: ReservoirSamplingCollector.internalBinaryRead(reader, reader.uint32(), options, (message.collector as any).reservoir_sampling)
                    };
                    break;
                case /* summa.proto.CountCollector count */ 3:
                    message.collector = {
                        oneofKind: "count",
                        count: CountCollector.internalBinaryRead(reader, reader.uint32(), options, (message.collector as any).count)
                    };
                    break;
                case /* summa.proto.FacetCollector facet */ 4:
                    message.collector = {
                        oneofKind: "facet",
                        facet: FacetCollector.internalBinaryRead(reader, reader.uint32(), options, (message.collector as any).facet)
                    };
                    break;
                case /* summa.proto.AggregationCollector aggregation */ 5:
                    message.collector = {
                        oneofKind: "aggregation",
                        aggregation: AggregationCollector.internalBinaryRead(reader, reader.uint32(), options, (message.collector as any).aggregation)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Collector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* summa.proto.TopDocsCollector top_docs = 1; */
        if (message.collector.oneofKind === "top_docs")
            TopDocsCollector.internalBinaryWrite(message.collector.top_docs, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.ReservoirSamplingCollector reservoir_sampling = 2; */
        if (message.collector.oneofKind === "reservoir_sampling")
            ReservoirSamplingCollector.internalBinaryWrite(message.collector.reservoir_sampling, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.CountCollector count = 3; */
        if (message.collector.oneofKind === "count")
            CountCollector.internalBinaryWrite(message.collector.count, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.FacetCollector facet = 4; */
        if (message.collector.oneofKind === "facet")
            FacetCollector.internalBinaryWrite(message.collector.facet, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.AggregationCollector aggregation = 5; */
        if (message.collector.oneofKind === "aggregation")
            AggregationCollector.internalBinaryWrite(message.collector.aggregation, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.Collector
 */
export const Collector = new Collector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CollectorOutput$Type extends MessageType<CollectorOutput> {
    constructor() {
        super("summa.proto.CollectorOutput", [
            { no: 1, name: "documents", kind: "message", oneof: "collector_output", T: () => DocumentsCollectorOutput },
            { no: 3, name: "count", kind: "message", oneof: "collector_output", T: () => CountCollectorOutput },
            { no: 4, name: "facet", kind: "message", oneof: "collector_output", T: () => FacetCollectorOutput },
            { no: 5, name: "aggregation", kind: "message", oneof: "collector_output", T: () => AggregationCollectorOutput }
        ]);
    }
    create(value?: PartialMessage<CollectorOutput>): CollectorOutput {
        const message = { collector_output: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CollectorOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CollectorOutput): CollectorOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* summa.proto.DocumentsCollectorOutput documents */ 1:
                    message.collector_output = {
                        oneofKind: "documents",
                        documents: DocumentsCollectorOutput.internalBinaryRead(reader, reader.uint32(), options, (message.collector_output as any).documents)
                    };
                    break;
                case /* summa.proto.CountCollectorOutput count */ 3:
                    message.collector_output = {
                        oneofKind: "count",
                        count: CountCollectorOutput.internalBinaryRead(reader, reader.uint32(), options, (message.collector_output as any).count)
                    };
                    break;
                case /* summa.proto.FacetCollectorOutput facet */ 4:
                    message.collector_output = {
                        oneofKind: "facet",
                        facet: FacetCollectorOutput.internalBinaryRead(reader, reader.uint32(), options, (message.collector_output as any).facet)
                    };
                    break;
                case /* summa.proto.AggregationCollectorOutput aggregation */ 5:
                    message.collector_output = {
                        oneofKind: "aggregation",
                        aggregation: AggregationCollectorOutput.internalBinaryRead(reader, reader.uint32(), options, (message.collector_output as any).aggregation)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CollectorOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* summa.proto.DocumentsCollectorOutput documents = 1; */
        if (message.collector_output.oneofKind === "documents")
            DocumentsCollectorOutput.internalBinaryWrite(message.collector_output.documents, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.CountCollectorOutput count = 3; */
        if (message.collector_output.oneofKind === "count")
            CountCollectorOutput.internalBinaryWrite(message.collector_output.count, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.FacetCollectorOutput facet = 4; */
        if (message.collector_output.oneofKind === "facet")
            FacetCollectorOutput.internalBinaryWrite(message.collector_output.facet, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.AggregationCollectorOutput aggregation = 5; */
        if (message.collector_output.oneofKind === "aggregation")
            AggregationCollectorOutput.internalBinaryWrite(message.collector_output.aggregation, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.CollectorOutput
 */
export const CollectorOutput = new CollectorOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CountCollector$Type extends MessageType<CountCollector> {
    constructor() {
        super("summa.proto.CountCollector", []);
    }
    create(value?: PartialMessage<CountCollector>): CountCollector {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CountCollector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CountCollector): CountCollector {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CountCollector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.CountCollector
 */
export const CountCollector = new CountCollector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CountCollectorOutput$Type extends MessageType<CountCollectorOutput> {
    constructor() {
        super("summa.proto.CountCollectorOutput", [
            { no: 1, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CountCollectorOutput>): CountCollectorOutput {
        const message = { count: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CountCollectorOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CountCollectorOutput): CountCollectorOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 count */ 1:
                    message.count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CountCollectorOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 count = 1; */
        if (message.count !== 0)
            writer.tag(1, WireType.Varint).uint32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.CountCollectorOutput
 */
export const CountCollectorOutput = new CountCollectorOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FacetCollector$Type extends MessageType<FacetCollector> {
    constructor() {
        super("summa.proto.FacetCollector", [
            { no: 1, name: "field", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "facets", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FacetCollector>): FacetCollector {
        const message = { field: "", facets: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FacetCollector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FacetCollector): FacetCollector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string field */ 1:
                    message.field = reader.string();
                    break;
                case /* repeated string facets */ 2:
                    message.facets.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FacetCollector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string field = 1; */
        if (message.field !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.field);
        /* repeated string facets = 2; */
        for (let i = 0; i < message.facets.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.facets[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.FacetCollector
 */
export const FacetCollector = new FacetCollector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FacetCollectorOutput$Type extends MessageType<FacetCollectorOutput> {
    constructor() {
        super("summa.proto.FacetCollectorOutput", [
            { no: 1, name: "facet_counts", kind: "map", localName: "facet_counts", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ } }
        ]);
    }
    create(value?: PartialMessage<FacetCollectorOutput>): FacetCollectorOutput {
        const message = { facet_counts: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FacetCollectorOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FacetCollectorOutput): FacetCollectorOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, uint64> facet_counts */ 1:
                    this.binaryReadMap1(message.facet_counts, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: FacetCollectorOutput["facet_counts"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof FacetCollectorOutput["facet_counts"] | undefined, val: FacetCollectorOutput["facet_counts"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.uint64().toBigInt();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field summa.proto.FacetCollectorOutput.facet_counts");
            }
        }
        map[key ?? ""] = val ?? 0n;
    }
    internalBinaryWrite(message: FacetCollectorOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, uint64> facet_counts = 1; */
        for (let k of Object.keys(message.facet_counts))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).uint64(message.facet_counts[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.FacetCollectorOutput
 */
export const FacetCollectorOutput = new FacetCollectorOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReservoirSamplingCollector$Type extends MessageType<ReservoirSamplingCollector> {
    constructor() {
        super("summa.proto.ReservoirSamplingCollector", [
            { no: 1, name: "limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "fields", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "removed_fields", kind: "scalar", localName: "removed_fields", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReservoirSamplingCollector>): ReservoirSamplingCollector {
        const message = { limit: 0, fields: [], removed_fields: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReservoirSamplingCollector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReservoirSamplingCollector): ReservoirSamplingCollector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 limit */ 1:
                    message.limit = reader.uint32();
                    break;
                case /* repeated string fields */ 2:
                    message.fields.push(reader.string());
                    break;
                case /* repeated string removed_fields */ 3:
                    message.removed_fields.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReservoirSamplingCollector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Varint).uint32(message.limit);
        /* repeated string fields = 2; */
        for (let i = 0; i < message.fields.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.fields[i]);
        /* repeated string removed_fields = 3; */
        for (let i = 0; i < message.removed_fields.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.removed_fields[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.ReservoirSamplingCollector
 */
export const ReservoirSamplingCollector = new ReservoirSamplingCollector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RandomDocument$Type extends MessageType<RandomDocument> {
    constructor() {
        super("summa.proto.RandomDocument", [
            { no: 1, name: "document", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "score", kind: "message", T: () => Score },
            { no: 3, name: "index_alias", kind: "scalar", localName: "index_alias", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RandomDocument>): RandomDocument {
        const message = { document: "", index_alias: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RandomDocument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RandomDocument): RandomDocument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string document */ 1:
                    message.document = reader.string();
                    break;
                case /* summa.proto.Score score */ 2:
                    message.score = Score.internalBinaryRead(reader, reader.uint32(), options, message.score);
                    break;
                case /* string index_alias */ 3:
                    message.index_alias = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RandomDocument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string document = 1; */
        if (message.document !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.document);
        /* summa.proto.Score score = 2; */
        if (message.score)
            Score.internalBinaryWrite(message.score, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string index_alias = 3; */
        if (message.index_alias !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.index_alias);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.RandomDocument
 */
export const RandomDocument = new RandomDocument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReservoirSamplingCollectorOutput$Type extends MessageType<ReservoirSamplingCollectorOutput> {
    constructor() {
        super("summa.proto.ReservoirSamplingCollectorOutput", [
            { no: 1, name: "documents", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RandomDocument }
        ]);
    }
    create(value?: PartialMessage<ReservoirSamplingCollectorOutput>): ReservoirSamplingCollectorOutput {
        const message = { documents: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReservoirSamplingCollectorOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReservoirSamplingCollectorOutput): ReservoirSamplingCollectorOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated summa.proto.RandomDocument documents */ 1:
                    message.documents.push(RandomDocument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReservoirSamplingCollectorOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated summa.proto.RandomDocument documents = 1; */
        for (let i = 0; i < message.documents.length; i++)
            RandomDocument.internalBinaryWrite(message.documents[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.ReservoirSamplingCollectorOutput
 */
export const ReservoirSamplingCollectorOutput = new ReservoirSamplingCollectorOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TopDocsCollector$Type extends MessageType<TopDocsCollector> {
    constructor() {
        super("summa.proto.TopDocsCollector", [
            { no: 1, name: "limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "offset", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "scorer", kind: "message", T: () => Scorer },
            { no: 4, name: "snippet_configs", kind: "map", localName: "snippet_configs", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 5, name: "explain", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "fields", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "removed_fields", kind: "scalar", localName: "removed_fields", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TopDocsCollector>): TopDocsCollector {
        const message = { limit: 0, offset: 0, snippet_configs: {}, explain: false, fields: [], removed_fields: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TopDocsCollector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TopDocsCollector): TopDocsCollector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 limit */ 1:
                    message.limit = reader.uint32();
                    break;
                case /* uint32 offset */ 2:
                    message.offset = reader.uint32();
                    break;
                case /* optional summa.proto.Scorer scorer */ 3:
                    message.scorer = Scorer.internalBinaryRead(reader, reader.uint32(), options, message.scorer);
                    break;
                case /* map<string, uint32> snippet_configs */ 4:
                    this.binaryReadMap4(message.snippet_configs, reader, options);
                    break;
                case /* bool explain */ 5:
                    message.explain = reader.bool();
                    break;
                case /* repeated string fields */ 6:
                    message.fields.push(reader.string());
                    break;
                case /* repeated string removed_fields */ 7:
                    message.removed_fields.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: TopDocsCollector["snippet_configs"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TopDocsCollector["snippet_configs"] | undefined, val: TopDocsCollector["snippet_configs"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field summa.proto.TopDocsCollector.snippet_configs");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: TopDocsCollector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Varint).uint32(message.limit);
        /* uint32 offset = 2; */
        if (message.offset !== 0)
            writer.tag(2, WireType.Varint).uint32(message.offset);
        /* optional summa.proto.Scorer scorer = 3; */
        if (message.scorer)
            Scorer.internalBinaryWrite(message.scorer, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* map<string, uint32> snippet_configs = 4; */
        for (let k of Object.keys(message.snippet_configs))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).uint32(message.snippet_configs[k]).join();
        /* bool explain = 5; */
        if (message.explain !== false)
            writer.tag(5, WireType.Varint).bool(message.explain);
        /* repeated string fields = 6; */
        for (let i = 0; i < message.fields.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.fields[i]);
        /* repeated string removed_fields = 7; */
        for (let i = 0; i < message.excluded_fields.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.excluded_fields[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.TopDocsCollector
 */
export const TopDocsCollector = new TopDocsCollector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentsCollectorOutput$Type extends MessageType<DocumentsCollectorOutput> {
    constructor() {
        super("summa.proto.DocumentsCollectorOutput", [
            { no: 1, name: "scored_documents", kind: "message", localName: "scored_documents", repeat: 1 /*RepeatType.PACKED*/, T: () => ScoredDocument },
            { no: 2, name: "has_next", kind: "scalar", localName: "has_next", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentsCollectorOutput>): DocumentsCollectorOutput {
        const message = { scored_documents: [], has_next: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DocumentsCollectorOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentsCollectorOutput): DocumentsCollectorOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated summa.proto.ScoredDocument scored_documents */ 1:
                    message.scored_documents.push(ScoredDocument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool has_next */ 2:
                    message.has_next = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentsCollectorOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated summa.proto.ScoredDocument scored_documents = 1; */
        for (let i = 0; i < message.scored_documents.length; i++)
            ScoredDocument.internalBinaryWrite(message.scored_documents[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool has_next = 2; */
        if (message.has_next !== false)
            writer.tag(2, WireType.Varint).bool(message.has_next);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.DocumentsCollectorOutput
 */
export const DocumentsCollectorOutput = new DocumentsCollectorOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AggregationCollector$Type extends MessageType<AggregationCollector> {
    constructor() {
        super("summa.proto.AggregationCollector", [
            { no: 1, name: "aggregations", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AggregationCollector>): AggregationCollector {
        const message = { aggregations: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AggregationCollector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AggregationCollector): AggregationCollector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string aggregations */ 1:
                    message.aggregations = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AggregationCollector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string aggregations = 1; */
        if (message.aggregations !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.aggregations);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.AggregationCollector
 */
export const AggregationCollector = new AggregationCollector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AggregationCollectorOutput$Type extends MessageType<AggregationCollectorOutput> {
    constructor() {
        super("summa.proto.AggregationCollectorOutput", [
            { no: 1, name: "aggregation_results", kind: "scalar", localName: "aggregation_results", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AggregationCollectorOutput>): AggregationCollectorOutput {
        const message = { aggregation_results: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AggregationCollectorOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AggregationCollectorOutput): AggregationCollectorOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string aggregation_results */ 1:
                    message.aggregation_results = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AggregationCollectorOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string aggregation_results = 1; */
        if (message.aggregation_results !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.aggregation_results);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.AggregationCollectorOutput
 */
export const AggregationCollectorOutput = new AggregationCollectorOutput$Type();
