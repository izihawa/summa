// @generated by protobuf-ts 2.9.1 with parameter use_proto_field_name
// @generated from protobuf file "index_service.proto" (package "summa.proto", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { IndexApi } from "./index_service";
import type { WarmupIndexResponse } from "./index_service";
import type { WarmupIndexRequest } from "./index_service";
import type { VacuumIndexResponse } from "./index_service";
import type { VacuumIndexRequest } from "./index_service";
import type { SetIndexAliasResponse } from "./index_service";
import type { SetIndexAliasRequest } from "./index_service";
import type { MergeSegmentsResponse } from "./index_service";
import type { MergeSegmentsRequest } from "./index_service";
import type { IndexDocumentResponse } from "./index_service";
import type { IndexDocumentRequest } from "./index_service";
import type { IndexDocumentStreamResponse } from "./index_service";
import type { IndexDocumentStreamRequest } from "./index_service";
import type { ClientStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { GetIndicesResponse } from "./index_service";
import type { GetIndicesRequest } from "./index_service";
import type { GetIndexResponse } from "./index_service";
import type { GetIndexRequest } from "./index_service";
import type { GetIndicesAliasesResponse } from "./index_service";
import type { GetIndicesAliasesRequest } from "./index_service";
import type { DocumentsResponse } from "./index_service";
import type { DocumentsRequest } from "./index_service";
import type { ServerStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { DeleteIndexResponse } from "./index_service";
import type { DeleteIndexRequest } from "./index_service";
import type { DeleteDocumentsResponse } from "./index_service";
import type { DeleteDocumentsRequest } from "./index_service";
import type { CopyIndexResponse } from "./index_service";
import type { CopyIndexRequest } from "./index_service";
import type { CreateIndexResponse } from "./index_service";
import type { CreateIndexRequest } from "./index_service";
import type { CopyDocumentsResponse } from "./index_service";
import type { CopyDocumentsRequest } from "./index_service";
import type { CommitIndexResponse } from "./index_service";
import type { CommitIndexRequest } from "./index_service";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { AttachIndexResponse } from "./index_service";
import type { AttachIndexRequest } from "./index_service";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * Manages indices
 *
 * @generated from protobuf service summa.proto.IndexApi
 */
export interface IIndexApiClient {
    /**
     * Attaches index to Summa server. Attaching allows to incorporate and start using of downloaded or network indices
     *
     * @generated from protobuf rpc: attach_index(summa.proto.AttachIndexRequest) returns (summa.proto.AttachIndexResponse);
     */
    attachIndex(input: AttachIndexRequest, options?: RpcOptions): UnaryCall<AttachIndexRequest, AttachIndexResponse>;
    /**
     * Committing all collected writes to the index
     *
     * @generated from protobuf rpc: commit_index(summa.proto.CommitIndexRequest) returns (summa.proto.CommitIndexResponse);
     */
    commitIndex(input: CommitIndexRequest, options?: RpcOptions): UnaryCall<CommitIndexRequest, CommitIndexResponse>;
    /**
     * Copy documents from one index to another
     *
     * @generated from protobuf rpc: copy_documents(summa.proto.CopyDocumentsRequest) returns (summa.proto.CopyDocumentsResponse);
     */
    copyDocuments(input: CopyDocumentsRequest, options?: RpcOptions): UnaryCall<CopyDocumentsRequest, CopyDocumentsResponse>;
    /**
     * Creates new index from scratch
     *
     * @generated from protobuf rpc: create_index(summa.proto.CreateIndexRequest) returns (summa.proto.CreateIndexResponse);
     */
    createIndex(input: CreateIndexRequest, options?: RpcOptions): UnaryCall<CreateIndexRequest, CreateIndexResponse>;
    /**
     * Creates new index from scratch
     *
     * @generated from protobuf rpc: copy_index(summa.proto.CopyIndexRequest) returns (summa.proto.CopyIndexResponse);
     */
    copyIndex(input: CopyIndexRequest, options?: RpcOptions): UnaryCall<CopyIndexRequest, CopyIndexResponse>;
    /**
     * Deletes single document from the index by its primary key (therefore, index must have primary key)
     *
     * @generated from protobuf rpc: delete_documents(summa.proto.DeleteDocumentsRequest) returns (summa.proto.DeleteDocumentsResponse);
     */
    deleteDocuments(input: DeleteDocumentsRequest, options?: RpcOptions): UnaryCall<DeleteDocumentsRequest, DeleteDocumentsResponse>;
    /**
     * Deletes index and physically removes file in the case of `FileEngine`
     *
     * @generated from protobuf rpc: delete_index(summa.proto.DeleteIndexRequest) returns (summa.proto.DeleteIndexResponse);
     */
    deleteIndex(input: DeleteIndexRequest, options?: RpcOptions): UnaryCall<DeleteIndexRequest, DeleteIndexResponse>;
    /**
     * Stream of all documents from the index
     *
     * @generated from protobuf rpc: documents(summa.proto.DocumentsRequest) returns (stream summa.proto.DocumentsResponse);
     */
    documents(input: DocumentsRequest, options?: RpcOptions): ServerStreamingCall<DocumentsRequest, DocumentsResponse>;
    /**
     * Gets all existing index aliases
     *
     * @generated from protobuf rpc: get_indices_aliases(summa.proto.GetIndicesAliasesRequest) returns (summa.proto.GetIndicesAliasesResponse);
     */
    getIndicesAliases(input: GetIndicesAliasesRequest, options?: RpcOptions): UnaryCall<GetIndicesAliasesRequest, GetIndicesAliasesResponse>;
    /**
     * Gets index description
     *
     * @generated from protobuf rpc: get_index(summa.proto.GetIndexRequest) returns (summa.proto.GetIndexResponse);
     */
    getIndex(input: GetIndexRequest, options?: RpcOptions): UnaryCall<GetIndexRequest, GetIndexResponse>;
    /**
     * Gets all existing index descriptions
     *
     * @generated from protobuf rpc: get_indices(summa.proto.GetIndicesRequest) returns (summa.proto.GetIndicesResponse);
     */
    getIndices(input: GetIndicesRequest, options?: RpcOptions): UnaryCall<GetIndicesRequest, GetIndicesResponse>;
    /**
     * Adds document to the index in a streaming way
     *
     * @generated from protobuf rpc: index_document_stream(stream summa.proto.IndexDocumentStreamRequest) returns (summa.proto.IndexDocumentStreamResponse);
     */
    indexDocumentStream(options?: RpcOptions): ClientStreamingCall<IndexDocumentStreamRequest, IndexDocumentStreamResponse>;
    /**
     * Adds document to the index
     *
     * @generated from protobuf rpc: index_document(summa.proto.IndexDocumentRequest) returns (summa.proto.IndexDocumentResponse);
     */
    indexDocument(input: IndexDocumentRequest, options?: RpcOptions): UnaryCall<IndexDocumentRequest, IndexDocumentResponse>;
    /**
     * Merges multiple segments into a single one. Used for service purposes
     *
     * @generated from protobuf rpc: merge_segments(summa.proto.MergeSegmentsRequest) returns (summa.proto.MergeSegmentsResponse);
     */
    mergeSegments(input: MergeSegmentsRequest, options?: RpcOptions): UnaryCall<MergeSegmentsRequest, MergeSegmentsResponse>;
    /**
     * Sets or replaces existing index alias
     *
     * @generated from protobuf rpc: set_index_alias(summa.proto.SetIndexAliasRequest) returns (summa.proto.SetIndexAliasResponse);
     */
    setIndexAlias(input: SetIndexAliasRequest, options?: RpcOptions): UnaryCall<SetIndexAliasRequest, SetIndexAliasResponse>;
    /**
     * Removes deletions from all segments
     *
     * @generated from protobuf rpc: vacuum_index(summa.proto.VacuumIndexRequest) returns (summa.proto.VacuumIndexResponse);
     */
    vacuumIndex(input: VacuumIndexRequest, options?: RpcOptions): UnaryCall<VacuumIndexRequest, VacuumIndexResponse>;
    /**
     * Loads all hot parts of the index into the memory
     *
     * @generated from protobuf rpc: warmup_index(summa.proto.WarmupIndexRequest) returns (summa.proto.WarmupIndexResponse);
     */
    warmupIndex(input: WarmupIndexRequest, options?: RpcOptions): UnaryCall<WarmupIndexRequest, WarmupIndexResponse>;
}
/**
 * Manages indices
 *
 * @generated from protobuf service summa.proto.IndexApi
 */
export class IndexApiClient implements IIndexApiClient, ServiceInfo {
    typeName = IndexApi.typeName;
    methods = IndexApi.methods;
    options = IndexApi.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Attaches index to Summa server. Attaching allows to incorporate and start using of downloaded or network indices
     *
     * @generated from protobuf rpc: attach_index(summa.proto.AttachIndexRequest) returns (summa.proto.AttachIndexResponse);
     */
    attachIndex(input: AttachIndexRequest, options?: RpcOptions): UnaryCall<AttachIndexRequest, AttachIndexResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<AttachIndexRequest, AttachIndexResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Committing all collected writes to the index
     *
     * @generated from protobuf rpc: commit_index(summa.proto.CommitIndexRequest) returns (summa.proto.CommitIndexResponse);
     */
    commitIndex(input: CommitIndexRequest, options?: RpcOptions): UnaryCall<CommitIndexRequest, CommitIndexResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<CommitIndexRequest, CommitIndexResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Copy documents from one index to another
     *
     * @generated from protobuf rpc: copy_documents(summa.proto.CopyDocumentsRequest) returns (summa.proto.CopyDocumentsResponse);
     */
    copyDocuments(input: CopyDocumentsRequest, options?: RpcOptions): UnaryCall<CopyDocumentsRequest, CopyDocumentsResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<CopyDocumentsRequest, CopyDocumentsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Creates new index from scratch
     *
     * @generated from protobuf rpc: create_index(summa.proto.CreateIndexRequest) returns (summa.proto.CreateIndexResponse);
     */
    createIndex(input: CreateIndexRequest, options?: RpcOptions): UnaryCall<CreateIndexRequest, CreateIndexResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<CreateIndexRequest, CreateIndexResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Creates new index from scratch
     *
     * @generated from protobuf rpc: copy_index(summa.proto.CopyIndexRequest) returns (summa.proto.CopyIndexResponse);
     */
    copyIndex(input: CopyIndexRequest, options?: RpcOptions): UnaryCall<CopyIndexRequest, CopyIndexResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<CopyIndexRequest, CopyIndexResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Deletes single document from the index by its primary key (therefore, index must have primary key)
     *
     * @generated from protobuf rpc: delete_documents(summa.proto.DeleteDocumentsRequest) returns (summa.proto.DeleteDocumentsResponse);
     */
    deleteDocuments(input: DeleteDocumentsRequest, options?: RpcOptions): UnaryCall<DeleteDocumentsRequest, DeleteDocumentsResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<DeleteDocumentsRequest, DeleteDocumentsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Deletes index and physically removes file in the case of `FileEngine`
     *
     * @generated from protobuf rpc: delete_index(summa.proto.DeleteIndexRequest) returns (summa.proto.DeleteIndexResponse);
     */
    deleteIndex(input: DeleteIndexRequest, options?: RpcOptions): UnaryCall<DeleteIndexRequest, DeleteIndexResponse> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<DeleteIndexRequest, DeleteIndexResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Stream of all documents from the index
     *
     * @generated from protobuf rpc: documents(summa.proto.DocumentsRequest) returns (stream summa.proto.DocumentsResponse);
     */
    documents(input: DocumentsRequest, options?: RpcOptions): ServerStreamingCall<DocumentsRequest, DocumentsResponse> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<DocumentsRequest, DocumentsResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Gets all existing index aliases
     *
     * @generated from protobuf rpc: get_indices_aliases(summa.proto.GetIndicesAliasesRequest) returns (summa.proto.GetIndicesAliasesResponse);
     */
    getIndicesAliases(input: GetIndicesAliasesRequest, options?: RpcOptions): UnaryCall<GetIndicesAliasesRequest, GetIndicesAliasesResponse> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetIndicesAliasesRequest, GetIndicesAliasesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Gets index description
     *
     * @generated from protobuf rpc: get_index(summa.proto.GetIndexRequest) returns (summa.proto.GetIndexResponse);
     */
    getIndex(input: GetIndexRequest, options?: RpcOptions): UnaryCall<GetIndexRequest, GetIndexResponse> {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetIndexRequest, GetIndexResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Gets all existing index descriptions
     *
     * @generated from protobuf rpc: get_indices(summa.proto.GetIndicesRequest) returns (summa.proto.GetIndicesResponse);
     */
    getIndices(input: GetIndicesRequest, options?: RpcOptions): UnaryCall<GetIndicesRequest, GetIndicesResponse> {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetIndicesRequest, GetIndicesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Adds document to the index in a streaming way
     *
     * @generated from protobuf rpc: index_document_stream(stream summa.proto.IndexDocumentStreamRequest) returns (summa.proto.IndexDocumentStreamResponse);
     */
    indexDocumentStream(options?: RpcOptions): ClientStreamingCall<IndexDocumentStreamRequest, IndexDocumentStreamResponse> {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return stackIntercept<IndexDocumentStreamRequest, IndexDocumentStreamResponse>("clientStreaming", this._transport, method, opt);
    }
    /**
     * Adds document to the index
     *
     * @generated from protobuf rpc: index_document(summa.proto.IndexDocumentRequest) returns (summa.proto.IndexDocumentResponse);
     */
    indexDocument(input: IndexDocumentRequest, options?: RpcOptions): UnaryCall<IndexDocumentRequest, IndexDocumentResponse> {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return stackIntercept<IndexDocumentRequest, IndexDocumentResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Merges multiple segments into a single one. Used for service purposes
     *
     * @generated from protobuf rpc: merge_segments(summa.proto.MergeSegmentsRequest) returns (summa.proto.MergeSegmentsResponse);
     */
    mergeSegments(input: MergeSegmentsRequest, options?: RpcOptions): UnaryCall<MergeSegmentsRequest, MergeSegmentsResponse> {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        return stackIntercept<MergeSegmentsRequest, MergeSegmentsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Sets or replaces existing index alias
     *
     * @generated from protobuf rpc: set_index_alias(summa.proto.SetIndexAliasRequest) returns (summa.proto.SetIndexAliasResponse);
     */
    setIndexAlias(input: SetIndexAliasRequest, options?: RpcOptions): UnaryCall<SetIndexAliasRequest, SetIndexAliasResponse> {
        const method = this.methods[14], opt = this._transport.mergeOptions(options);
        return stackIntercept<SetIndexAliasRequest, SetIndexAliasResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Removes deletions from all segments
     *
     * @generated from protobuf rpc: vacuum_index(summa.proto.VacuumIndexRequest) returns (summa.proto.VacuumIndexResponse);
     */
    vacuumIndex(input: VacuumIndexRequest, options?: RpcOptions): UnaryCall<VacuumIndexRequest, VacuumIndexResponse> {
        const method = this.methods[15], opt = this._transport.mergeOptions(options);
        return stackIntercept<VacuumIndexRequest, VacuumIndexResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Loads all hot parts of the index into the memory
     *
     * @generated from protobuf rpc: warmup_index(summa.proto.WarmupIndexRequest) returns (summa.proto.WarmupIndexResponse);
     */
    warmupIndex(input: WarmupIndexRequest, options?: RpcOptions): UnaryCall<WarmupIndexRequest, WarmupIndexResponse> {
        const method = this.methods[16], opt = this._transport.mergeOptions(options);
        return stackIntercept<WarmupIndexRequest, WarmupIndexResponse>("unary", this._transport, method, opt, input);
    }
}
