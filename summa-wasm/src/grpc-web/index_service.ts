// @generated by protobuf-ts 2.9.1 with parameter long_type_string,use_proto_field_name
// @generated from protobuf file "index_service.proto" (package "summa.proto", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Query } from "./query";
import { Order } from "./utils";
import { QueryParserConfig } from "./query";
/**
 * Merge policy that describes how to merge committed segments
 *
 * @generated from protobuf message summa.proto.MergePolicy
 */
export interface MergePolicy {
    /**
     * @generated from protobuf oneof: merge_policy
     */
    merge_policy: {
        oneofKind: "log";
        /**
         * @generated from protobuf field: summa.proto.LogMergePolicy log = 11;
         */
        log: LogMergePolicy;
    } | {
        oneofKind: "temporal";
        /**
         * @generated from protobuf field: summa.proto.TemporalMergePolicy temporal = 12;
         */
        temporal: TemporalMergePolicy;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Attach file engine request
 *
 * @generated from protobuf message summa.proto.AttachFileEngineRequest
 */
export interface AttachFileEngineRequest {
}
/**
 * Attach remote engine request
 *
 * @generated from protobuf message summa.proto.AttachRemoteEngineRequest
 */
export interface AttachRemoteEngineRequest {
    /**
     * @generated from protobuf field: summa.proto.RemoteEngineConfig config = 1;
     */
    config?: RemoteEngineConfig;
}
/**
 * Attach index request
 *
 * @generated from protobuf message summa.proto.AttachIndexRequest
 */
export interface AttachIndexRequest {
    /**
     * Index name for attaching
     *
     * @generated from protobuf field: string index_name = 1;
     */
    index_name: string;
    /**
     * @generated from protobuf oneof: index_engine
     */
    index_engine: {
        oneofKind: "file";
        /**
         * @generated from protobuf field: summa.proto.AttachFileEngineRequest file = 2;
         */
        file: AttachFileEngineRequest;
    } | {
        oneofKind: "remote";
        /**
         * @generated from protobuf field: summa.proto.AttachRemoteEngineRequest remote = 3;
         */
        remote: AttachRemoteEngineRequest;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: summa.proto.MergePolicy merge_policy = 10;
     */
    merge_policy?: MergePolicy;
    /**
     * @generated from protobuf field: summa.proto.QueryParserConfig query_parser_config = 11;
     */
    query_parser_config?: QueryParserConfig;
}
/**
 * Description of the attached index
 *
 * @generated from protobuf message summa.proto.AttachIndexResponse
 */
export interface AttachIndexResponse {
    /**
     * @generated from protobuf field: summa.proto.IndexDescription index = 1;
     */
    index?: IndexDescription;
}
/**
 * Store the state of index to the storage
 *
 * @generated from protobuf message summa.proto.CommitIndexRequest
 */
export interface CommitIndexRequest {
    /**
     * @generated from protobuf field: string index_name = 1;
     */
    index_name: string;
    /**
     * @generated from protobuf field: bool with_hotcache = 2;
     */
    with_hotcache: boolean;
}
/**
 * Returned data from the commit command
 *
 * @generated from protobuf message summa.proto.CommitIndexResponse
 */
export interface CommitIndexResponse {
    /**
     * Pure time spent for committing
     *
     * @generated from protobuf field: double elapsed_secs = 1;
     */
    elapsed_secs: number;
}
/**
 * Copy documents from one index to another. Their schemes must be compatible
 *
 * @generated from protobuf message summa.proto.CopyDocumentsRequest
 */
export interface CopyDocumentsRequest {
    /**
     * Where documents should be taken from
     *
     * @generated from protobuf field: string source_index_name = 1;
     */
    source_index_name: string;
    /**
     * Where documents should be copied to
     *
     * @generated from protobuf field: string target_index_name = 2;
     */
    target_index_name: string;
    /**
     * How to deal with conflicts on unique fields. Recommended to set to DoNothing for large updates and maintain uniqueness in your application
     *
     * @generated from protobuf field: optional summa.proto.ConflictStrategy conflict_strategy = 3;
     */
    conflict_strategy?: ConflictStrategy;
}
/**
 * Copy documents response
 *
 * @generated from protobuf message summa.proto.CopyDocumentsResponse
 */
export interface CopyDocumentsResponse {
    /**
     * @generated from protobuf field: double elapsed_secs = 1;
     */
    elapsed_secs: number;
    /**
     * @generated from protobuf field: uint32 copied_documents = 2;
     */
    copied_documents: number;
}
/**
 * Request that changes index engine. Currently possible to convert File to IPFS
 *
 * @generated from protobuf message summa.proto.CopyIndexRequest
 */
export interface CopyIndexRequest {
    /**
     * Name of index that will be migrated. It will be left intact after migration.
     *
     * @generated from protobuf field: string source_index_name = 1;
     */
    source_index_name: string;
    /**
     * Name of index that will be created
     *
     * @generated from protobuf field: string target_index_name = 2;
     */
    target_index_name: string;
    /**
     * @generated from protobuf oneof: target_index_engine
     */
    target_index_engine: {
        oneofKind: "file";
        /**
         * @generated from protobuf field: summa.proto.CreateFileEngineRequest file = 3;
         */
        file: CreateFileEngineRequest;
    } | {
        oneofKind: "memory";
        /**
         * @generated from protobuf field: summa.proto.CreateMemoryEngineRequest memory = 4;
         */
        memory: CreateMemoryEngineRequest;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: summa.proto.MergePolicy merge_policy = 6;
     */
    merge_policy?: MergePolicy;
}
/**
 * Response describing migrated index
 *
 * @generated from protobuf message summa.proto.CopyIndexResponse
 */
export interface CopyIndexResponse {
    /**
     * @generated from protobuf field: summa.proto.IndexDescription index = 1;
     */
    index?: IndexDescription;
}
/**
 * @generated from protobuf message summa.proto.SortByField
 */
export interface SortByField {
    /**
     * @generated from protobuf field: string field = 1;
     */
    field: string;
    /**
     * @generated from protobuf field: summa.proto.Order order = 2;
     */
    order: Order;
}
/**
 * @generated from protobuf message summa.proto.CreateFileEngineRequest
 */
export interface CreateFileEngineRequest {
}
/**
 * @generated from protobuf message summa.proto.CreateMemoryEngineRequest
 */
export interface CreateMemoryEngineRequest {
}
/**
 * @generated from protobuf message summa.proto.MappedField
 */
export interface MappedField {
    /**
     * @generated from protobuf field: string source_field = 1;
     */
    source_field: string;
    /**
     * @generated from protobuf field: string target_field = 2;
     */
    target_field: string;
}
/**
 * @generated from protobuf message summa.proto.IndexAttributes
 */
export interface IndexAttributes {
    /**
     * Timestamp when index has been created
     *
     * @generated from protobuf field: uint64 created_at = 1;
     */
    created_at: string;
    /**
     * Unique fields of the index. Summa maintains unique constraint on them and uses for deduplicating data
     *
     * @generated from protobuf field: repeated string unique_fields = 2;
     */
    unique_fields: string[];
    /**
     * Multi fields is ones that may have multiple values and processed as lists. All other fields will be forcefully converted to singular value
     *
     * @generated from protobuf field: repeated string multi_fields = 4;
     */
    multi_fields: string[];
    /**
     * Text index description
     *
     * @generated from protobuf field: optional string description = 6;
     */
    description?: string;
    /**
     * @generated from protobuf field: summa.proto.ConflictStrategy conflict_strategy = 8;
     */
    conflict_strategy: ConflictStrategy;
    /**
     * @generated from protobuf field: repeated summa.proto.MappedField mapped_fields = 9;
     */
    mapped_fields: MappedField[];
}
/**
 * Request for index creation
 *
 * @generated from protobuf message summa.proto.CreateIndexRequest
 */
export interface CreateIndexRequest {
    /**
     * Index name
     *
     * @generated from protobuf field: string index_name = 1;
     */
    index_name: string;
    /**
     * @generated from protobuf oneof: index_engine
     */
    index_engine: {
        oneofKind: "file";
        /**
         * @generated from protobuf field: summa.proto.CreateFileEngineRequest file = 7;
         */
        file: CreateFileEngineRequest;
    } | {
        oneofKind: "memory";
        /**
         * @generated from protobuf field: summa.proto.CreateMemoryEngineRequest memory = 8;
         */
        memory: CreateMemoryEngineRequest;
    } | {
        oneofKind: undefined;
    };
    /**
     * Index schema in Tantivy format
     *
     * @generated from protobuf field: string schema = 2;
     */
    schema: string;
    /**
     * Compression for store
     *
     * @generated from protobuf field: summa.proto.Compression compression = 3;
     */
    compression: Compression;
    /**
     * Size of store blocks
     *
     * @generated from protobuf field: optional uint32 blocksize = 4;
     */
    blocksize?: number;
    /**
     * Field for sorting
     *
     * @generated from protobuf field: optional summa.proto.SortByField sort_by_field = 5;
     */
    sort_by_field?: SortByField;
    /**
     * Optional index fields
     *
     * @generated from protobuf field: summa.proto.IndexAttributes index_attributes = 6;
     */
    index_attributes?: IndexAttributes;
    /**
     * Merge policy
     *
     * @generated from protobuf field: summa.proto.MergePolicy merge_policy = 20;
     */
    merge_policy?: MergePolicy;
    /**
     * @generated from protobuf field: summa.proto.QueryParserConfig query_parser_config = 21;
     */
    query_parser_config?: QueryParserConfig;
}
/**
 * @generated from protobuf message summa.proto.CreateIndexResponse
 */
export interface CreateIndexResponse {
    /**
     * @generated from protobuf field: summa.proto.IndexDescription index = 1;
     */
    index?: IndexDescription;
}
/**
 * @generated from protobuf message summa.proto.DeleteDocumentsRequest
 */
export interface DeleteDocumentsRequest {
    /**
     * @generated from protobuf field: string index_name = 1;
     */
    index_name: string;
    /**
     * @generated from protobuf field: summa.proto.Query query = 2;
     */
    query?: Query;
}
/**
 * @generated from protobuf message summa.proto.DeleteDocumentsResponse
 */
export interface DeleteDocumentsResponse {
    /**
     * @generated from protobuf field: uint64 deleted_documents = 1;
     */
    deleted_documents: string;
}
/**
 * @generated from protobuf message summa.proto.DeleteIndexRequest
 */
export interface DeleteIndexRequest {
    /**
     * @generated from protobuf field: string index_name = 1;
     */
    index_name: string;
}
/**
 * @generated from protobuf message summa.proto.DeleteIndexResponse
 */
export interface DeleteIndexResponse {
    /**
     * @generated from protobuf field: string deleted_index_name = 1;
     */
    deleted_index_name: string;
}
/**
 * @generated from protobuf message summa.proto.GetIndicesAliasesRequest
 */
export interface GetIndicesAliasesRequest {
}
/**
 * @generated from protobuf message summa.proto.GetIndicesAliasesResponse
 */
export interface GetIndicesAliasesResponse {
    /**
     * @generated from protobuf field: map<string, string> indices_aliases = 1;
     */
    indices_aliases: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message summa.proto.GetIndexRequest
 */
export interface GetIndexRequest {
    /**
     * @generated from protobuf field: string index_name = 1;
     */
    index_name: string;
}
/**
 * @generated from protobuf message summa.proto.GetIndexResponse
 */
export interface GetIndexResponse {
    /**
     * @generated from protobuf field: summa.proto.IndexDescription index = 1;
     */
    index?: IndexDescription;
}
/**
 * @generated from protobuf message summa.proto.GetIndicesRequest
 */
export interface GetIndicesRequest {
}
/**
 * @generated from protobuf message summa.proto.GetIndicesResponse
 */
export interface GetIndicesResponse {
    /**
     * @generated from protobuf field: repeated string index_names = 1;
     */
    index_names: string[];
}
/**
 * @generated from protobuf message summa.proto.IndexDocumentStreamRequest
 */
export interface IndexDocumentStreamRequest {
    /**
     * @generated from protobuf field: string index_name = 1;
     */
    index_name: string;
    /**
     * @generated from protobuf field: repeated bytes documents = 2;
     */
    documents: Uint8Array[];
    /**
     * @generated from protobuf field: optional summa.proto.ConflictStrategy conflict_strategy = 3;
     */
    conflict_strategy?: ConflictStrategy;
}
/**
 * @generated from protobuf message summa.proto.IndexDocumentStreamResponse
 */
export interface IndexDocumentStreamResponse {
    /**
     * @generated from protobuf field: double elapsed_secs = 1;
     */
    elapsed_secs: number;
    /**
     * @generated from protobuf field: uint64 success_docs = 2;
     */
    success_docs: string;
    /**
     * @generated from protobuf field: uint64 failed_docs = 3;
     */
    failed_docs: string;
}
/**
 * @generated from protobuf message summa.proto.IndexDocumentRequest
 */
export interface IndexDocumentRequest {
    /**
     * @generated from protobuf field: string index_name = 1;
     */
    index_name: string;
    /**
     * @generated from protobuf field: bytes document = 2;
     */
    document: Uint8Array;
}
/**
 * @generated from protobuf message summa.proto.IndexDocumentResponse
 */
export interface IndexDocumentResponse {
}
/**
 * @generated from protobuf message summa.proto.MergeSegmentsRequest
 */
export interface MergeSegmentsRequest {
    /**
     * @generated from protobuf field: string index_name = 1;
     */
    index_name: string;
    /**
     * @generated from protobuf field: repeated string segment_ids = 2;
     */
    segment_ids: string[];
}
/**
 * @generated from protobuf message summa.proto.MergeSegmentsResponse
 */
export interface MergeSegmentsResponse {
    /**
     * @generated from protobuf field: optional string segment_id = 1;
     */
    segment_id?: string;
}
/**
 * @generated from protobuf message summa.proto.SetIndexAliasRequest
 */
export interface SetIndexAliasRequest {
    /**
     * @generated from protobuf field: string index_alias = 1;
     */
    index_alias: string;
    /**
     * @generated from protobuf field: string index_name = 2;
     */
    index_name: string;
}
/**
 * @generated from protobuf message summa.proto.SetIndexAliasResponse
 */
export interface SetIndexAliasResponse {
    /**
     * If set, equals to the previous alias of the index
     *
     * @generated from protobuf field: optional string old_index_name = 1;
     */
    old_index_name?: string;
}
/**
 * Request a stream of all documents from the index
 *
 * @generated from protobuf message summa.proto.DocumentsRequest
 */
export interface DocumentsRequest {
    /**
     * @generated from protobuf field: string index_name = 1;
     */
    index_name: string;
    /**
     * @generated from protobuf field: repeated string fields = 2;
     */
    fields: string[];
    /**
     * @generated from protobuf field: optional summa.proto.Query query_filter = 3;
     */
    query_filter?: Query;
}
/**
 * Single document from the index
 *
 * @generated from protobuf message summa.proto.DocumentsResponse
 */
export interface DocumentsResponse {
    /**
     * @generated from protobuf field: string document = 1;
     */
    document: string;
}
/**
 * @generated from protobuf message summa.proto.VacuumIndexRequest
 */
export interface VacuumIndexRequest {
    /**
     * @generated from protobuf field: string index_name = 1;
     */
    index_name: string;
    /**
     * @generated from protobuf field: repeated string excluded_segments = 2;
     */
    excluded_segments: string[];
}
/**
 * @generated from protobuf message summa.proto.VacuumIndexResponse
 */
export interface VacuumIndexResponse {
    /**
     * @generated from protobuf field: uint64 freed_space_bytes = 1;
     */
    freed_space_bytes: string;
}
/**
 * @generated from protobuf message summa.proto.WarmupIndexRequest
 */
export interface WarmupIndexRequest {
    /**
     * @generated from protobuf field: string index_name = 1;
     */
    index_name: string;
    /**
     * If set to false, only term dictionaries will be warmed, otherwise the entire index will be read.
     *
     * @generated from protobuf field: bool is_full = 2;
     */
    is_full: boolean;
}
/**
 * @generated from protobuf message summa.proto.WarmupIndexResponse
 */
export interface WarmupIndexResponse {
    /**
     * Time spent in warming operation
     *
     * @generated from protobuf field: double elapsed_secs = 1;
     */
    elapsed_secs: number;
}
/**
 * @generated from protobuf message summa.proto.FileEngineConfig
 */
export interface FileEngineConfig {
    /**
     * @generated from protobuf field: string path = 1;
     */
    path: string;
}
/**
 * @generated from protobuf message summa.proto.MemoryEngineConfig
 */
export interface MemoryEngineConfig {
    /**
     * Schema of the index for memory engine
     *
     * @generated from protobuf field: string schema = 1;
     */
    schema: string;
}
/**
 * @generated from protobuf message summa.proto.CacheConfig
 */
export interface CacheConfig {
    /**
     * Total cache size in bytes
     *
     * @generated from protobuf field: uint64 cache_size = 1;
     */
    cache_size: string;
}
/**
 * Remote HTTP engine config
 *
 * @generated from protobuf message summa.proto.RemoteEngineConfig
 */
export interface RemoteEngineConfig {
    /**
     * Which method should be used to request remote endpoint
     *
     * @generated from protobuf field: string method = 1;
     */
    method: string;
    /**
     * URL template which will be used to generate real URL by variables substitution
     *
     * @generated from protobuf field: string url_template = 2;
     */
    url_template: string;
    /**
     * Headers template which will be used to generate real URL by variables substitution
     *
     * @generated from protobuf field: map<string, string> headers_template = 3;
     */
    headers_template: {
        [key: string]: string;
    };
    /**
     * Description of the cache for the engine
     *
     * @generated from protobuf field: summa.proto.CacheConfig cache_config = 4;
     */
    cache_config?: CacheConfig;
    /**
     * Timeout for the request
     *
     * @generated from protobuf field: optional uint32 timeout_ms = 5;
     */
    timeout_ms?: number;
}
/**
 * Merge policy for implementing [LogMergePolicy](https://docs.rs/tantivy/latest/tantivy/merge_policy/struct.LogMergePolicy.html)
 *
 * @generated from protobuf message summa.proto.LogMergePolicy
 */
export interface LogMergePolicy {
    /**
     * Set if once merged segment should be left intact
     *
     * @generated from protobuf field: bool is_frozen = 1;
     */
    is_frozen: boolean;
}
/**
 * Merge policy for compressing old segments
 *
 * @generated from protobuf message summa.proto.TemporalMergePolicy
 */
export interface TemporalMergePolicy {
    /**
     * @generated from protobuf field: uint64 merge_older_then_secs = 1;
     */
    merge_older_then_secs: string;
}
/**
 * Description of the `IndexEngine` responsible for managing files in the persistent storage
 *
 * @generated from protobuf message summa.proto.IndexEngineConfig
 */
export interface IndexEngineConfig {
    /**
     * @generated from protobuf oneof: config
     */
    config: {
        oneofKind: "file";
        /**
         * @generated from protobuf field: summa.proto.FileEngineConfig file = 1;
         */
        file: FileEngineConfig;
    } | {
        oneofKind: "memory";
        /**
         * @generated from protobuf field: summa.proto.MemoryEngineConfig memory = 2;
         */
        memory: MemoryEngineConfig;
    } | {
        oneofKind: "remote";
        /**
         * @generated from protobuf field: summa.proto.RemoteEngineConfig remote = 3;
         */
        remote: RemoteEngineConfig;
    } | {
        oneofKind: undefined;
    };
    /**
     * Merge policy
     *
     * @generated from protobuf field: summa.proto.MergePolicy merge_policy = 10;
     */
    merge_policy?: MergePolicy;
    /**
     * @generated from protobuf field: summa.proto.QueryParserConfig query_parser_config = 11;
     */
    query_parser_config?: QueryParserConfig;
}
/**
 * Description containing `Index` metadata fields
 *
 * @generated from protobuf message summa.proto.IndexDescription
 */
export interface IndexDescription {
    /**
     * @generated from protobuf field: string index_name = 1;
     */
    index_name: string;
    /**
     * All index aliases
     *
     * @generated from protobuf field: repeated string index_aliases = 2;
     */
    index_aliases: string[];
    /**
     * @generated from protobuf field: summa.proto.IndexEngineConfig index_engine = 3;
     */
    index_engine?: IndexEngineConfig;
    /**
     * The number of committed documents
     *
     * @generated from protobuf field: uint64 num_docs = 4;
     */
    num_docs: string;
    /**
     * Used compression for `store`
     *
     * @generated from protobuf field: summa.proto.Compression compression = 5;
     */
    compression: Compression;
    /**
     * All custom index attributes
     *
     * @generated from protobuf field: summa.proto.IndexAttributes index_attributes = 6;
     */
    index_attributes?: IndexAttributes;
}
/**
 * Indexing operations that contains document serialized in JSON format
 *
 * @generated from protobuf message summa.proto.IndexDocumentOperation
 */
export interface IndexDocumentOperation {
    /**
     * @generated from protobuf field: bytes document = 1;
     */
    document: Uint8Array;
}
/**
 * Message that should be put in Kafka for ingesting by Summa consumers
 *
 * @generated from protobuf message summa.proto.IndexOperation
 */
export interface IndexOperation {
    /**
     * @generated from protobuf oneof: operation
     */
    operation: {
        oneofKind: "index_document";
        /**
         * @generated from protobuf field: summa.proto.IndexDocumentOperation index_document = 2;
         */
        index_document: IndexDocumentOperation;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum summa.proto.ConflictStrategy
 */
export enum ConflictStrategy {
    /**
     * @generated from protobuf enum value: DO_NOTHING = 0;
     */
    DO_NOTHING = 0,
    /**
     * @generated from protobuf enum value: OVERWRITE_ALWAYS = 1;
     */
    OVERWRITE_ALWAYS = 1,
    /**
     * @generated from protobuf enum value: OVERWRITE = 2;
     */
    OVERWRITE = 2,
    /**
     * @generated from protobuf enum value: MERGE = 3;
     */
    MERGE = 3
}
/**
 * Compression library for store, implies on both performance and occupied disk space
 *
 * @generated from protobuf enum summa.proto.Compression
 */
export enum Compression {
    /**
     * @generated from protobuf enum value: None = 0;
     */
    None = 0,
    /**
     * @generated from protobuf enum value: Zstd = 4;
     */
    Zstd = 4,
    /**
     * @generated from protobuf enum value: Zstd7 = 5;
     */
    Zstd7 = 5,
    /**
     * @generated from protobuf enum value: Zstd9 = 6;
     */
    Zstd9 = 6,
    /**
     * @generated from protobuf enum value: Zstd14 = 7;
     */
    Zstd14 = 7,
    /**
     * @generated from protobuf enum value: Zstd19 = 8;
     */
    Zstd19 = 8,
    /**
     * @generated from protobuf enum value: Zstd22 = 9;
     */
    Zstd22 = 9
}
// @generated message type with reflection information, may provide speed optimized methods
class MergePolicy$Type extends MessageType<MergePolicy> {
    constructor() {
        super("summa.proto.MergePolicy", [
            { no: 11, name: "log", kind: "message", oneof: "merge_policy", T: () => LogMergePolicy },
            { no: 12, name: "temporal", kind: "message", oneof: "merge_policy", T: () => TemporalMergePolicy }
        ]);
    }
    create(value?: PartialMessage<MergePolicy>): MergePolicy {
        const message = { merge_policy: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MergePolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MergePolicy): MergePolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* summa.proto.LogMergePolicy log */ 11:
                    message.merge_policy = {
                        oneofKind: "log",
                        log: LogMergePolicy.internalBinaryRead(reader, reader.uint32(), options, (message.merge_policy as any).log)
                    };
                    break;
                case /* summa.proto.TemporalMergePolicy temporal */ 12:
                    message.merge_policy = {
                        oneofKind: "temporal",
                        temporal: TemporalMergePolicy.internalBinaryRead(reader, reader.uint32(), options, (message.merge_policy as any).temporal)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MergePolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* summa.proto.LogMergePolicy log = 11; */
        if (message.merge_policy.oneofKind === "log")
            LogMergePolicy.internalBinaryWrite(message.merge_policy.log, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.TemporalMergePolicy temporal = 12; */
        if (message.merge_policy.oneofKind === "temporal")
            TemporalMergePolicy.internalBinaryWrite(message.merge_policy.temporal, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.MergePolicy
 */
export const MergePolicy = new MergePolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttachFileEngineRequest$Type extends MessageType<AttachFileEngineRequest> {
    constructor() {
        super("summa.proto.AttachFileEngineRequest", []);
    }
    create(value?: PartialMessage<AttachFileEngineRequest>): AttachFileEngineRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AttachFileEngineRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttachFileEngineRequest): AttachFileEngineRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: AttachFileEngineRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.AttachFileEngineRequest
 */
export const AttachFileEngineRequest = new AttachFileEngineRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttachRemoteEngineRequest$Type extends MessageType<AttachRemoteEngineRequest> {
    constructor() {
        super("summa.proto.AttachRemoteEngineRequest", [
            { no: 1, name: "config", kind: "message", T: () => RemoteEngineConfig }
        ]);
    }
    create(value?: PartialMessage<AttachRemoteEngineRequest>): AttachRemoteEngineRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AttachRemoteEngineRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttachRemoteEngineRequest): AttachRemoteEngineRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* summa.proto.RemoteEngineConfig config */ 1:
                    message.config = RemoteEngineConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttachRemoteEngineRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* summa.proto.RemoteEngineConfig config = 1; */
        if (message.config)
            RemoteEngineConfig.internalBinaryWrite(message.config, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.AttachRemoteEngineRequest
 */
export const AttachRemoteEngineRequest = new AttachRemoteEngineRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttachIndexRequest$Type extends MessageType<AttachIndexRequest> {
    constructor() {
        super("summa.proto.AttachIndexRequest", [
            { no: 1, name: "index_name", kind: "scalar", localName: "index_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "file", kind: "message", oneof: "index_engine", T: () => AttachFileEngineRequest },
            { no: 3, name: "remote", kind: "message", oneof: "index_engine", T: () => AttachRemoteEngineRequest },
            { no: 10, name: "merge_policy", kind: "message", localName: "merge_policy", T: () => MergePolicy },
            { no: 11, name: "query_parser_config", kind: "message", localName: "query_parser_config", T: () => QueryParserConfig }
        ]);
    }
    create(value?: PartialMessage<AttachIndexRequest>): AttachIndexRequest {
        const message = { index_name: "", index_engine: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AttachIndexRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttachIndexRequest): AttachIndexRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string index_name */ 1:
                    message.index_name = reader.string();
                    break;
                case /* summa.proto.AttachFileEngineRequest file */ 2:
                    message.index_engine = {
                        oneofKind: "file",
                        file: AttachFileEngineRequest.internalBinaryRead(reader, reader.uint32(), options, (message.index_engine as any).file)
                    };
                    break;
                case /* summa.proto.AttachRemoteEngineRequest remote */ 3:
                    message.index_engine = {
                        oneofKind: "remote",
                        remote: AttachRemoteEngineRequest.internalBinaryRead(reader, reader.uint32(), options, (message.index_engine as any).remote)
                    };
                    break;
                case /* summa.proto.MergePolicy merge_policy */ 10:
                    message.merge_policy = MergePolicy.internalBinaryRead(reader, reader.uint32(), options, message.merge_policy);
                    break;
                case /* summa.proto.QueryParserConfig query_parser_config */ 11:
                    message.query_parser_config = QueryParserConfig.internalBinaryRead(reader, reader.uint32(), options, message.query_parser_config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttachIndexRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string index_name = 1; */
        if (message.index_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.index_name);
        /* summa.proto.AttachFileEngineRequest file = 2; */
        if (message.index_engine.oneofKind === "file")
            AttachFileEngineRequest.internalBinaryWrite(message.index_engine.file, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.AttachRemoteEngineRequest remote = 3; */
        if (message.index_engine.oneofKind === "remote")
            AttachRemoteEngineRequest.internalBinaryWrite(message.index_engine.remote, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.MergePolicy merge_policy = 10; */
        if (message.merge_policy)
            MergePolicy.internalBinaryWrite(message.merge_policy, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.QueryParserConfig query_parser_config = 11; */
        if (message.query_parser_config)
            QueryParserConfig.internalBinaryWrite(message.query_parser_config, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.AttachIndexRequest
 */
export const AttachIndexRequest = new AttachIndexRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttachIndexResponse$Type extends MessageType<AttachIndexResponse> {
    constructor() {
        super("summa.proto.AttachIndexResponse", [
            { no: 1, name: "index", kind: "message", T: () => IndexDescription }
        ]);
    }
    create(value?: PartialMessage<AttachIndexResponse>): AttachIndexResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AttachIndexResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttachIndexResponse): AttachIndexResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* summa.proto.IndexDescription index */ 1:
                    message.index = IndexDescription.internalBinaryRead(reader, reader.uint32(), options, message.index);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttachIndexResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* summa.proto.IndexDescription index = 1; */
        if (message.index)
            IndexDescription.internalBinaryWrite(message.index, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.AttachIndexResponse
 */
export const AttachIndexResponse = new AttachIndexResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommitIndexRequest$Type extends MessageType<CommitIndexRequest> {
    constructor() {
        super("summa.proto.CommitIndexRequest", [
            { no: 1, name: "index_name", kind: "scalar", localName: "index_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "with_hotcache", kind: "scalar", localName: "with_hotcache", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CommitIndexRequest>): CommitIndexRequest {
        const message = { index_name: "", with_hotcache: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CommitIndexRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommitIndexRequest): CommitIndexRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string index_name */ 1:
                    message.index_name = reader.string();
                    break;
                case /* bool with_hotcache */ 2:
                    message.with_hotcache = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommitIndexRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string index_name = 1; */
        if (message.index_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.index_name);
        /* bool with_hotcache = 2; */
        if (message.with_hotcache !== false)
            writer.tag(2, WireType.Varint).bool(message.with_hotcache);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.CommitIndexRequest
 */
export const CommitIndexRequest = new CommitIndexRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommitIndexResponse$Type extends MessageType<CommitIndexResponse> {
    constructor() {
        super("summa.proto.CommitIndexResponse", [
            { no: 1, name: "elapsed_secs", kind: "scalar", localName: "elapsed_secs", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<CommitIndexResponse>): CommitIndexResponse {
        const message = { elapsed_secs: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CommitIndexResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommitIndexResponse): CommitIndexResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double elapsed_secs */ 1:
                    message.elapsed_secs = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommitIndexResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double elapsed_secs = 1; */
        if (message.elapsed_secs !== 0)
            writer.tag(1, WireType.Bit64).double(message.elapsed_secs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.CommitIndexResponse
 */
export const CommitIndexResponse = new CommitIndexResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CopyDocumentsRequest$Type extends MessageType<CopyDocumentsRequest> {
    constructor() {
        super("summa.proto.CopyDocumentsRequest", [
            { no: 1, name: "source_index_name", kind: "scalar", localName: "source_index_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_index_name", kind: "scalar", localName: "target_index_name", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "conflict_strategy", kind: "enum", localName: "conflict_strategy", opt: true, T: () => ["summa.proto.ConflictStrategy", ConflictStrategy] }
        ]);
    }
    create(value?: PartialMessage<CopyDocumentsRequest>): CopyDocumentsRequest {
        const message = { source_index_name: "", target_index_name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CopyDocumentsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CopyDocumentsRequest): CopyDocumentsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string source_index_name */ 1:
                    message.source_index_name = reader.string();
                    break;
                case /* string target_index_name */ 2:
                    message.target_index_name = reader.string();
                    break;
                case /* optional summa.proto.ConflictStrategy conflict_strategy */ 3:
                    message.conflict_strategy = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CopyDocumentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string source_index_name = 1; */
        if (message.source_index_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.source_index_name);
        /* string target_index_name = 2; */
        if (message.target_index_name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.target_index_name);
        /* optional summa.proto.ConflictStrategy conflict_strategy = 3; */
        if (message.conflict_strategy !== undefined)
            writer.tag(3, WireType.Varint).int32(message.conflict_strategy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.CopyDocumentsRequest
 */
export const CopyDocumentsRequest = new CopyDocumentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CopyDocumentsResponse$Type extends MessageType<CopyDocumentsResponse> {
    constructor() {
        super("summa.proto.CopyDocumentsResponse", [
            { no: 1, name: "elapsed_secs", kind: "scalar", localName: "elapsed_secs", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "copied_documents", kind: "scalar", localName: "copied_documents", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CopyDocumentsResponse>): CopyDocumentsResponse {
        const message = { elapsed_secs: 0, copied_documents: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CopyDocumentsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CopyDocumentsResponse): CopyDocumentsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double elapsed_secs */ 1:
                    message.elapsed_secs = reader.double();
                    break;
                case /* uint32 copied_documents */ 2:
                    message.copied_documents = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CopyDocumentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double elapsed_secs = 1; */
        if (message.elapsed_secs !== 0)
            writer.tag(1, WireType.Bit64).double(message.elapsed_secs);
        /* uint32 copied_documents = 2; */
        if (message.copied_documents !== 0)
            writer.tag(2, WireType.Varint).uint32(message.copied_documents);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.CopyDocumentsResponse
 */
export const CopyDocumentsResponse = new CopyDocumentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CopyIndexRequest$Type extends MessageType<CopyIndexRequest> {
    constructor() {
        super("summa.proto.CopyIndexRequest", [
            { no: 1, name: "source_index_name", kind: "scalar", localName: "source_index_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_index_name", kind: "scalar", localName: "target_index_name", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "file", kind: "message", oneof: "target_index_engine", T: () => CreateFileEngineRequest },
            { no: 4, name: "memory", kind: "message", oneof: "target_index_engine", T: () => CreateMemoryEngineRequest },
            { no: 6, name: "merge_policy", kind: "message", localName: "merge_policy", T: () => MergePolicy }
        ]);
    }
    create(value?: PartialMessage<CopyIndexRequest>): CopyIndexRequest {
        const message = { source_index_name: "", target_index_name: "", target_index_engine: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CopyIndexRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CopyIndexRequest): CopyIndexRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string source_index_name */ 1:
                    message.source_index_name = reader.string();
                    break;
                case /* string target_index_name */ 2:
                    message.target_index_name = reader.string();
                    break;
                case /* summa.proto.CreateFileEngineRequest file */ 3:
                    message.target_index_engine = {
                        oneofKind: "file",
                        file: CreateFileEngineRequest.internalBinaryRead(reader, reader.uint32(), options, (message.target_index_engine as any).file)
                    };
                    break;
                case /* summa.proto.CreateMemoryEngineRequest memory */ 4:
                    message.target_index_engine = {
                        oneofKind: "memory",
                        memory: CreateMemoryEngineRequest.internalBinaryRead(reader, reader.uint32(), options, (message.target_index_engine as any).memory)
                    };
                    break;
                case /* summa.proto.MergePolicy merge_policy */ 6:
                    message.merge_policy = MergePolicy.internalBinaryRead(reader, reader.uint32(), options, message.merge_policy);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CopyIndexRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string source_index_name = 1; */
        if (message.source_index_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.source_index_name);
        /* string target_index_name = 2; */
        if (message.target_index_name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.target_index_name);
        /* summa.proto.CreateFileEngineRequest file = 3; */
        if (message.target_index_engine.oneofKind === "file")
            CreateFileEngineRequest.internalBinaryWrite(message.target_index_engine.file, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.CreateMemoryEngineRequest memory = 4; */
        if (message.target_index_engine.oneofKind === "memory")
            CreateMemoryEngineRequest.internalBinaryWrite(message.target_index_engine.memory, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.MergePolicy merge_policy = 6; */
        if (message.merge_policy)
            MergePolicy.internalBinaryWrite(message.merge_policy, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.CopyIndexRequest
 */
export const CopyIndexRequest = new CopyIndexRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CopyIndexResponse$Type extends MessageType<CopyIndexResponse> {
    constructor() {
        super("summa.proto.CopyIndexResponse", [
            { no: 1, name: "index", kind: "message", T: () => IndexDescription }
        ]);
    }
    create(value?: PartialMessage<CopyIndexResponse>): CopyIndexResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CopyIndexResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CopyIndexResponse): CopyIndexResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* summa.proto.IndexDescription index */ 1:
                    message.index = IndexDescription.internalBinaryRead(reader, reader.uint32(), options, message.index);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CopyIndexResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* summa.proto.IndexDescription index = 1; */
        if (message.index)
            IndexDescription.internalBinaryWrite(message.index, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.CopyIndexResponse
 */
export const CopyIndexResponse = new CopyIndexResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SortByField$Type extends MessageType<SortByField> {
    constructor() {
        super("summa.proto.SortByField", [
            { no: 1, name: "field", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order", kind: "enum", T: () => ["summa.proto.Order", Order] }
        ]);
    }
    create(value?: PartialMessage<SortByField>): SortByField {
        const message = { field: "", order: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SortByField>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SortByField): SortByField {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string field */ 1:
                    message.field = reader.string();
                    break;
                case /* summa.proto.Order order */ 2:
                    message.order = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SortByField, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string field = 1; */
        if (message.field !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.field);
        /* summa.proto.Order order = 2; */
        if (message.order !== 0)
            writer.tag(2, WireType.Varint).int32(message.order);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.SortByField
 */
export const SortByField = new SortByField$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateFileEngineRequest$Type extends MessageType<CreateFileEngineRequest> {
    constructor() {
        super("summa.proto.CreateFileEngineRequest", []);
    }
    create(value?: PartialMessage<CreateFileEngineRequest>): CreateFileEngineRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateFileEngineRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateFileEngineRequest): CreateFileEngineRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CreateFileEngineRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.CreateFileEngineRequest
 */
export const CreateFileEngineRequest = new CreateFileEngineRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateMemoryEngineRequest$Type extends MessageType<CreateMemoryEngineRequest> {
    constructor() {
        super("summa.proto.CreateMemoryEngineRequest", []);
    }
    create(value?: PartialMessage<CreateMemoryEngineRequest>): CreateMemoryEngineRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateMemoryEngineRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateMemoryEngineRequest): CreateMemoryEngineRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CreateMemoryEngineRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.CreateMemoryEngineRequest
 */
export const CreateMemoryEngineRequest = new CreateMemoryEngineRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MappedField$Type extends MessageType<MappedField> {
    constructor() {
        super("summa.proto.MappedField", [
            { no: 1, name: "source_field", kind: "scalar", localName: "source_field", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_field", kind: "scalar", localName: "target_field", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MappedField>): MappedField {
        const message = { source_field: "", target_field: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MappedField>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MappedField): MappedField {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string source_field */ 1:
                    message.source_field = reader.string();
                    break;
                case /* string target_field */ 2:
                    message.target_field = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MappedField, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string source_field = 1; */
        if (message.source_field !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.source_field);
        /* string target_field = 2; */
        if (message.target_field !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.target_field);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.MappedField
 */
export const MappedField = new MappedField$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndexAttributes$Type extends MessageType<IndexAttributes> {
    constructor() {
        super("summa.proto.IndexAttributes", [
            { no: 1, name: "created_at", kind: "scalar", localName: "created_at", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "unique_fields", kind: "scalar", localName: "unique_fields", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "multi_fields", kind: "scalar", localName: "multi_fields", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "conflict_strategy", kind: "enum", localName: "conflict_strategy", T: () => ["summa.proto.ConflictStrategy", ConflictStrategy] },
            { no: 9, name: "mapped_fields", kind: "message", localName: "mapped_fields", repeat: 1 /*RepeatType.PACKED*/, T: () => MappedField }
        ]);
    }
    create(value?: PartialMessage<IndexAttributes>): IndexAttributes {
        const message = { created_at: "0", unique_fields: [], multi_fields: [], conflict_strategy: 0, mapped_fields: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IndexAttributes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndexAttributes): IndexAttributes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 created_at */ 1:
                    message.created_at = reader.uint64().toString();
                    break;
                case /* repeated string unique_fields */ 2:
                    message.unique_fields.push(reader.string());
                    break;
                case /* repeated string multi_fields */ 4:
                    message.multi_fields.push(reader.string());
                    break;
                case /* optional string description */ 6:
                    message.description = reader.string();
                    break;
                case /* summa.proto.ConflictStrategy conflict_strategy */ 8:
                    message.conflict_strategy = reader.int32();
                    break;
                case /* repeated summa.proto.MappedField mapped_fields */ 9:
                    message.mapped_fields.push(MappedField.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IndexAttributes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 created_at = 1; */
        if (message.created_at !== "0")
            writer.tag(1, WireType.Varint).uint64(message.created_at);
        /* repeated string unique_fields = 2; */
        for (let i = 0; i < message.unique_fields.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.unique_fields[i]);
        /* repeated string multi_fields = 4; */
        for (let i = 0; i < message.multi_fields.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.multi_fields[i]);
        /* optional string description = 6; */
        if (message.description !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.description);
        /* summa.proto.ConflictStrategy conflict_strategy = 8; */
        if (message.conflict_strategy !== 0)
            writer.tag(8, WireType.Varint).int32(message.conflict_strategy);
        /* repeated summa.proto.MappedField mapped_fields = 9; */
        for (let i = 0; i < message.mapped_fields.length; i++)
            MappedField.internalBinaryWrite(message.mapped_fields[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.IndexAttributes
 */
export const IndexAttributes = new IndexAttributes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateIndexRequest$Type extends MessageType<CreateIndexRequest> {
    constructor() {
        super("summa.proto.CreateIndexRequest", [
            { no: 1, name: "index_name", kind: "scalar", localName: "index_name", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "file", kind: "message", oneof: "index_engine", T: () => CreateFileEngineRequest },
            { no: 8, name: "memory", kind: "message", oneof: "index_engine", T: () => CreateMemoryEngineRequest },
            { no: 2, name: "schema", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "compression", kind: "enum", T: () => ["summa.proto.Compression", Compression] },
            { no: 4, name: "blocksize", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "sort_by_field", kind: "message", localName: "sort_by_field", T: () => SortByField },
            { no: 6, name: "index_attributes", kind: "message", localName: "index_attributes", T: () => IndexAttributes },
            { no: 20, name: "merge_policy", kind: "message", localName: "merge_policy", T: () => MergePolicy },
            { no: 21, name: "query_parser_config", kind: "message", localName: "query_parser_config", T: () => QueryParserConfig }
        ]);
    }
    create(value?: PartialMessage<CreateIndexRequest>): CreateIndexRequest {
        const message = { index_name: "", index_engine: { oneofKind: undefined }, schema: "", compression: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateIndexRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateIndexRequest): CreateIndexRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string index_name */ 1:
                    message.index_name = reader.string();
                    break;
                case /* summa.proto.CreateFileEngineRequest file */ 7:
                    message.index_engine = {
                        oneofKind: "file",
                        file: CreateFileEngineRequest.internalBinaryRead(reader, reader.uint32(), options, (message.index_engine as any).file)
                    };
                    break;
                case /* summa.proto.CreateMemoryEngineRequest memory */ 8:
                    message.index_engine = {
                        oneofKind: "memory",
                        memory: CreateMemoryEngineRequest.internalBinaryRead(reader, reader.uint32(), options, (message.index_engine as any).memory)
                    };
                    break;
                case /* string schema */ 2:
                    message.schema = reader.string();
                    break;
                case /* summa.proto.Compression compression */ 3:
                    message.compression = reader.int32();
                    break;
                case /* optional uint32 blocksize */ 4:
                    message.blocksize = reader.uint32();
                    break;
                case /* optional summa.proto.SortByField sort_by_field */ 5:
                    message.sort_by_field = SortByField.internalBinaryRead(reader, reader.uint32(), options, message.sort_by_field);
                    break;
                case /* summa.proto.IndexAttributes index_attributes */ 6:
                    message.index_attributes = IndexAttributes.internalBinaryRead(reader, reader.uint32(), options, message.index_attributes);
                    break;
                case /* summa.proto.MergePolicy merge_policy */ 20:
                    message.merge_policy = MergePolicy.internalBinaryRead(reader, reader.uint32(), options, message.merge_policy);
                    break;
                case /* summa.proto.QueryParserConfig query_parser_config */ 21:
                    message.query_parser_config = QueryParserConfig.internalBinaryRead(reader, reader.uint32(), options, message.query_parser_config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateIndexRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string index_name = 1; */
        if (message.index_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.index_name);
        /* summa.proto.CreateFileEngineRequest file = 7; */
        if (message.index_engine.oneofKind === "file")
            CreateFileEngineRequest.internalBinaryWrite(message.index_engine.file, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.CreateMemoryEngineRequest memory = 8; */
        if (message.index_engine.oneofKind === "memory")
            CreateMemoryEngineRequest.internalBinaryWrite(message.index_engine.memory, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string schema = 2; */
        if (message.schema !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.schema);
        /* summa.proto.Compression compression = 3; */
        if (message.compression !== 0)
            writer.tag(3, WireType.Varint).int32(message.compression);
        /* optional uint32 blocksize = 4; */
        if (message.blocksize !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.blocksize);
        /* optional summa.proto.SortByField sort_by_field = 5; */
        if (message.sort_by_field)
            SortByField.internalBinaryWrite(message.sort_by_field, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.IndexAttributes index_attributes = 6; */
        if (message.index_attributes)
            IndexAttributes.internalBinaryWrite(message.index_attributes, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.MergePolicy merge_policy = 20; */
        if (message.merge_policy)
            MergePolicy.internalBinaryWrite(message.merge_policy, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.QueryParserConfig query_parser_config = 21; */
        if (message.query_parser_config)
            QueryParserConfig.internalBinaryWrite(message.query_parser_config, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.CreateIndexRequest
 */
export const CreateIndexRequest = new CreateIndexRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateIndexResponse$Type extends MessageType<CreateIndexResponse> {
    constructor() {
        super("summa.proto.CreateIndexResponse", [
            { no: 1, name: "index", kind: "message", T: () => IndexDescription }
        ]);
    }
    create(value?: PartialMessage<CreateIndexResponse>): CreateIndexResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateIndexResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateIndexResponse): CreateIndexResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* summa.proto.IndexDescription index */ 1:
                    message.index = IndexDescription.internalBinaryRead(reader, reader.uint32(), options, message.index);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateIndexResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* summa.proto.IndexDescription index = 1; */
        if (message.index)
            IndexDescription.internalBinaryWrite(message.index, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.CreateIndexResponse
 */
export const CreateIndexResponse = new CreateIndexResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteDocumentsRequest$Type extends MessageType<DeleteDocumentsRequest> {
    constructor() {
        super("summa.proto.DeleteDocumentsRequest", [
            { no: 1, name: "index_name", kind: "scalar", localName: "index_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "query", kind: "message", T: () => Query }
        ]);
    }
    create(value?: PartialMessage<DeleteDocumentsRequest>): DeleteDocumentsRequest {
        const message = { index_name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteDocumentsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteDocumentsRequest): DeleteDocumentsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string index_name */ 1:
                    message.index_name = reader.string();
                    break;
                case /* summa.proto.Query query */ 2:
                    message.query = Query.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteDocumentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string index_name = 1; */
        if (message.index_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.index_name);
        /* summa.proto.Query query = 2; */
        if (message.query)
            Query.internalBinaryWrite(message.query, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.DeleteDocumentsRequest
 */
export const DeleteDocumentsRequest = new DeleteDocumentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteDocumentsResponse$Type extends MessageType<DeleteDocumentsResponse> {
    constructor() {
        super("summa.proto.DeleteDocumentsResponse", [
            { no: 1, name: "deleted_documents", kind: "scalar", localName: "deleted_documents", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteDocumentsResponse>): DeleteDocumentsResponse {
        const message = { deleted_documents: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteDocumentsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteDocumentsResponse): DeleteDocumentsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 deleted_documents */ 1:
                    message.deleted_documents = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteDocumentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 deleted_documents = 1; */
        if (message.deleted_documents !== "0")
            writer.tag(1, WireType.Varint).uint64(message.deleted_documents);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.DeleteDocumentsResponse
 */
export const DeleteDocumentsResponse = new DeleteDocumentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteIndexRequest$Type extends MessageType<DeleteIndexRequest> {
    constructor() {
        super("summa.proto.DeleteIndexRequest", [
            { no: 1, name: "index_name", kind: "scalar", localName: "index_name", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteIndexRequest>): DeleteIndexRequest {
        const message = { index_name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteIndexRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteIndexRequest): DeleteIndexRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string index_name */ 1:
                    message.index_name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteIndexRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string index_name = 1; */
        if (message.index_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.index_name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.DeleteIndexRequest
 */
export const DeleteIndexRequest = new DeleteIndexRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteIndexResponse$Type extends MessageType<DeleteIndexResponse> {
    constructor() {
        super("summa.proto.DeleteIndexResponse", [
            { no: 1, name: "deleted_index_name", kind: "scalar", localName: "deleted_index_name", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteIndexResponse>): DeleteIndexResponse {
        const message = { deleted_index_name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteIndexResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteIndexResponse): DeleteIndexResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string deleted_index_name */ 1:
                    message.deleted_index_name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteIndexResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string deleted_index_name = 1; */
        if (message.deleted_index_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.deleted_index_name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.DeleteIndexResponse
 */
export const DeleteIndexResponse = new DeleteIndexResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIndicesAliasesRequest$Type extends MessageType<GetIndicesAliasesRequest> {
    constructor() {
        super("summa.proto.GetIndicesAliasesRequest", []);
    }
    create(value?: PartialMessage<GetIndicesAliasesRequest>): GetIndicesAliasesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetIndicesAliasesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIndicesAliasesRequest): GetIndicesAliasesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetIndicesAliasesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.GetIndicesAliasesRequest
 */
export const GetIndicesAliasesRequest = new GetIndicesAliasesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIndicesAliasesResponse$Type extends MessageType<GetIndicesAliasesResponse> {
    constructor() {
        super("summa.proto.GetIndicesAliasesResponse", [
            { no: 1, name: "indices_aliases", kind: "map", localName: "indices_aliases", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<GetIndicesAliasesResponse>): GetIndicesAliasesResponse {
        const message = { indices_aliases: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetIndicesAliasesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIndicesAliasesResponse): GetIndicesAliasesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> indices_aliases */ 1:
                    this.binaryReadMap1(message.indices_aliases, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetIndicesAliasesResponse["indices_aliases"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetIndicesAliasesResponse["indices_aliases"] | undefined, val: GetIndicesAliasesResponse["indices_aliases"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field summa.proto.GetIndicesAliasesResponse.indices_aliases");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: GetIndicesAliasesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> indices_aliases = 1; */
        for (let k of Object.keys(message.indices_aliases))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.indices_aliases[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.GetIndicesAliasesResponse
 */
export const GetIndicesAliasesResponse = new GetIndicesAliasesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIndexRequest$Type extends MessageType<GetIndexRequest> {
    constructor() {
        super("summa.proto.GetIndexRequest", [
            { no: 1, name: "index_name", kind: "scalar", localName: "index_name", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetIndexRequest>): GetIndexRequest {
        const message = { index_name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetIndexRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIndexRequest): GetIndexRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string index_name */ 1:
                    message.index_name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIndexRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string index_name = 1; */
        if (message.index_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.index_name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.GetIndexRequest
 */
export const GetIndexRequest = new GetIndexRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIndexResponse$Type extends MessageType<GetIndexResponse> {
    constructor() {
        super("summa.proto.GetIndexResponse", [
            { no: 1, name: "index", kind: "message", T: () => IndexDescription }
        ]);
    }
    create(value?: PartialMessage<GetIndexResponse>): GetIndexResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetIndexResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIndexResponse): GetIndexResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* summa.proto.IndexDescription index */ 1:
                    message.index = IndexDescription.internalBinaryRead(reader, reader.uint32(), options, message.index);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIndexResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* summa.proto.IndexDescription index = 1; */
        if (message.index)
            IndexDescription.internalBinaryWrite(message.index, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.GetIndexResponse
 */
export const GetIndexResponse = new GetIndexResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIndicesRequest$Type extends MessageType<GetIndicesRequest> {
    constructor() {
        super("summa.proto.GetIndicesRequest", []);
    }
    create(value?: PartialMessage<GetIndicesRequest>): GetIndicesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetIndicesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIndicesRequest): GetIndicesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetIndicesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.GetIndicesRequest
 */
export const GetIndicesRequest = new GetIndicesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIndicesResponse$Type extends MessageType<GetIndicesResponse> {
    constructor() {
        super("summa.proto.GetIndicesResponse", [
            { no: 1, name: "index_names", kind: "scalar", localName: "index_names", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetIndicesResponse>): GetIndicesResponse {
        const message = { index_names: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetIndicesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIndicesResponse): GetIndicesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string index_names */ 1:
                    message.index_names.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIndicesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string index_names = 1; */
        for (let i = 0; i < message.index_names.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.index_names[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.GetIndicesResponse
 */
export const GetIndicesResponse = new GetIndicesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndexDocumentStreamRequest$Type extends MessageType<IndexDocumentStreamRequest> {
    constructor() {
        super("summa.proto.IndexDocumentStreamRequest", [
            { no: 1, name: "index_name", kind: "scalar", localName: "index_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "documents", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "conflict_strategy", kind: "enum", localName: "conflict_strategy", opt: true, T: () => ["summa.proto.ConflictStrategy", ConflictStrategy] }
        ]);
    }
    create(value?: PartialMessage<IndexDocumentStreamRequest>): IndexDocumentStreamRequest {
        const message = { index_name: "", documents: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IndexDocumentStreamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndexDocumentStreamRequest): IndexDocumentStreamRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string index_name */ 1:
                    message.index_name = reader.string();
                    break;
                case /* repeated bytes documents */ 2:
                    message.documents.push(reader.bytes());
                    break;
                case /* optional summa.proto.ConflictStrategy conflict_strategy */ 3:
                    message.conflict_strategy = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IndexDocumentStreamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string index_name = 1; */
        if (message.index_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.index_name);
        /* repeated bytes documents = 2; */
        for (let i = 0; i < message.documents.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.documents[i]);
        /* optional summa.proto.ConflictStrategy conflict_strategy = 3; */
        if (message.conflict_strategy !== undefined)
            writer.tag(3, WireType.Varint).int32(message.conflict_strategy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.IndexDocumentStreamRequest
 */
export const IndexDocumentStreamRequest = new IndexDocumentStreamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndexDocumentStreamResponse$Type extends MessageType<IndexDocumentStreamResponse> {
    constructor() {
        super("summa.proto.IndexDocumentStreamResponse", [
            { no: 1, name: "elapsed_secs", kind: "scalar", localName: "elapsed_secs", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "success_docs", kind: "scalar", localName: "success_docs", T: 4 /*ScalarType.UINT64*/ },
            { no: 3, name: "failed_docs", kind: "scalar", localName: "failed_docs", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<IndexDocumentStreamResponse>): IndexDocumentStreamResponse {
        const message = { elapsed_secs: 0, success_docs: "0", failed_docs: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IndexDocumentStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndexDocumentStreamResponse): IndexDocumentStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double elapsed_secs */ 1:
                    message.elapsed_secs = reader.double();
                    break;
                case /* uint64 success_docs */ 2:
                    message.success_docs = reader.uint64().toString();
                    break;
                case /* uint64 failed_docs */ 3:
                    message.failed_docs = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IndexDocumentStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double elapsed_secs = 1; */
        if (message.elapsed_secs !== 0)
            writer.tag(1, WireType.Bit64).double(message.elapsed_secs);
        /* uint64 success_docs = 2; */
        if (message.success_docs !== "0")
            writer.tag(2, WireType.Varint).uint64(message.success_docs);
        /* uint64 failed_docs = 3; */
        if (message.failed_docs !== "0")
            writer.tag(3, WireType.Varint).uint64(message.failed_docs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.IndexDocumentStreamResponse
 */
export const IndexDocumentStreamResponse = new IndexDocumentStreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndexDocumentRequest$Type extends MessageType<IndexDocumentRequest> {
    constructor() {
        super("summa.proto.IndexDocumentRequest", [
            { no: 1, name: "index_name", kind: "scalar", localName: "index_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "document", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<IndexDocumentRequest>): IndexDocumentRequest {
        const message = { index_name: "", document: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IndexDocumentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndexDocumentRequest): IndexDocumentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string index_name */ 1:
                    message.index_name = reader.string();
                    break;
                case /* bytes document */ 2:
                    message.document = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IndexDocumentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string index_name = 1; */
        if (message.index_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.index_name);
        /* bytes document = 2; */
        if (message.document.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.document);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.IndexDocumentRequest
 */
export const IndexDocumentRequest = new IndexDocumentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndexDocumentResponse$Type extends MessageType<IndexDocumentResponse> {
    constructor() {
        super("summa.proto.IndexDocumentResponse", []);
    }
    create(value?: PartialMessage<IndexDocumentResponse>): IndexDocumentResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IndexDocumentResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndexDocumentResponse): IndexDocumentResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: IndexDocumentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.IndexDocumentResponse
 */
export const IndexDocumentResponse = new IndexDocumentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MergeSegmentsRequest$Type extends MessageType<MergeSegmentsRequest> {
    constructor() {
        super("summa.proto.MergeSegmentsRequest", [
            { no: 1, name: "index_name", kind: "scalar", localName: "index_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "segment_ids", kind: "scalar", localName: "segment_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MergeSegmentsRequest>): MergeSegmentsRequest {
        const message = { index_name: "", segment_ids: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MergeSegmentsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MergeSegmentsRequest): MergeSegmentsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string index_name */ 1:
                    message.index_name = reader.string();
                    break;
                case /* repeated string segment_ids */ 2:
                    message.segment_ids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MergeSegmentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string index_name = 1; */
        if (message.index_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.index_name);
        /* repeated string segment_ids = 2; */
        for (let i = 0; i < message.segment_ids.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.segment_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.MergeSegmentsRequest
 */
export const MergeSegmentsRequest = new MergeSegmentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MergeSegmentsResponse$Type extends MessageType<MergeSegmentsResponse> {
    constructor() {
        super("summa.proto.MergeSegmentsResponse", [
            { no: 1, name: "segment_id", kind: "scalar", localName: "segment_id", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MergeSegmentsResponse>): MergeSegmentsResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MergeSegmentsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MergeSegmentsResponse): MergeSegmentsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string segment_id */ 1:
                    message.segment_id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MergeSegmentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string segment_id = 1; */
        if (message.segment_id !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.segment_id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.MergeSegmentsResponse
 */
export const MergeSegmentsResponse = new MergeSegmentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetIndexAliasRequest$Type extends MessageType<SetIndexAliasRequest> {
    constructor() {
        super("summa.proto.SetIndexAliasRequest", [
            { no: 1, name: "index_alias", kind: "scalar", localName: "index_alias", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "index_name", kind: "scalar", localName: "index_name", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetIndexAliasRequest>): SetIndexAliasRequest {
        const message = { index_alias: "", index_name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetIndexAliasRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetIndexAliasRequest): SetIndexAliasRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string index_alias */ 1:
                    message.index_alias = reader.string();
                    break;
                case /* string index_name */ 2:
                    message.index_name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetIndexAliasRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string index_alias = 1; */
        if (message.index_alias !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.index_alias);
        /* string index_name = 2; */
        if (message.index_name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.index_name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.SetIndexAliasRequest
 */
export const SetIndexAliasRequest = new SetIndexAliasRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetIndexAliasResponse$Type extends MessageType<SetIndexAliasResponse> {
    constructor() {
        super("summa.proto.SetIndexAliasResponse", [
            { no: 1, name: "old_index_name", kind: "scalar", localName: "old_index_name", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetIndexAliasResponse>): SetIndexAliasResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetIndexAliasResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetIndexAliasResponse): SetIndexAliasResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string old_index_name */ 1:
                    message.old_index_name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetIndexAliasResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string old_index_name = 1; */
        if (message.old_index_name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.old_index_name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.SetIndexAliasResponse
 */
export const SetIndexAliasResponse = new SetIndexAliasResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentsRequest$Type extends MessageType<DocumentsRequest> {
    constructor() {
        super("summa.proto.DocumentsRequest", [
            { no: 1, name: "index_name", kind: "scalar", localName: "index_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fields", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "query_filter", kind: "message", localName: "query_filter", T: () => Query }
        ]);
    }
    create(value?: PartialMessage<DocumentsRequest>): DocumentsRequest {
        const message = { index_name: "", fields: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DocumentsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentsRequest): DocumentsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string index_name */ 1:
                    message.index_name = reader.string();
                    break;
                case /* repeated string fields */ 2:
                    message.fields.push(reader.string());
                    break;
                case /* optional summa.proto.Query query_filter */ 3:
                    message.query_filter = Query.internalBinaryRead(reader, reader.uint32(), options, message.query_filter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string index_name = 1; */
        if (message.index_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.index_name);
        /* repeated string fields = 2; */
        for (let i = 0; i < message.fields.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.fields[i]);
        /* optional summa.proto.Query query_filter = 3; */
        if (message.query_filter)
            Query.internalBinaryWrite(message.query_filter, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.DocumentsRequest
 */
export const DocumentsRequest = new DocumentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentsResponse$Type extends MessageType<DocumentsResponse> {
    constructor() {
        super("summa.proto.DocumentsResponse", [
            { no: 1, name: "document", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentsResponse>): DocumentsResponse {
        const message = { document: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DocumentsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentsResponse): DocumentsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string document */ 1:
                    message.document = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string document = 1; */
        if (message.document !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.document);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.DocumentsResponse
 */
export const DocumentsResponse = new DocumentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VacuumIndexRequest$Type extends MessageType<VacuumIndexRequest> {
    constructor() {
        super("summa.proto.VacuumIndexRequest", [
            { no: 1, name: "index_name", kind: "scalar", localName: "index_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "excluded_segments", kind: "scalar", localName: "excluded_segments", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VacuumIndexRequest>): VacuumIndexRequest {
        const message = { index_name: "", excluded_segments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VacuumIndexRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VacuumIndexRequest): VacuumIndexRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string index_name */ 1:
                    message.index_name = reader.string();
                    break;
                case /* repeated string excluded_segments */ 2:
                    message.excluded_segments.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VacuumIndexRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string index_name = 1; */
        if (message.index_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.index_name);
        /* repeated string excluded_segments = 2; */
        for (let i = 0; i < message.excluded_segments.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.excluded_segments[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.VacuumIndexRequest
 */
export const VacuumIndexRequest = new VacuumIndexRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VacuumIndexResponse$Type extends MessageType<VacuumIndexResponse> {
    constructor() {
        super("summa.proto.VacuumIndexResponse", [
            { no: 1, name: "freed_space_bytes", kind: "scalar", localName: "freed_space_bytes", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<VacuumIndexResponse>): VacuumIndexResponse {
        const message = { freed_space_bytes: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VacuumIndexResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VacuumIndexResponse): VacuumIndexResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 freed_space_bytes */ 1:
                    message.freed_space_bytes = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VacuumIndexResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 freed_space_bytes = 1; */
        if (message.freed_space_bytes !== "0")
            writer.tag(1, WireType.Varint).uint64(message.freed_space_bytes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.VacuumIndexResponse
 */
export const VacuumIndexResponse = new VacuumIndexResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WarmupIndexRequest$Type extends MessageType<WarmupIndexRequest> {
    constructor() {
        super("summa.proto.WarmupIndexRequest", [
            { no: 1, name: "index_name", kind: "scalar", localName: "index_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "is_full", kind: "scalar", localName: "is_full", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<WarmupIndexRequest>): WarmupIndexRequest {
        const message = { index_name: "", is_full: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WarmupIndexRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WarmupIndexRequest): WarmupIndexRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string index_name */ 1:
                    message.index_name = reader.string();
                    break;
                case /* bool is_full */ 2:
                    message.is_full = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WarmupIndexRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string index_name = 1; */
        if (message.index_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.index_name);
        /* bool is_full = 2; */
        if (message.is_full !== false)
            writer.tag(2, WireType.Varint).bool(message.is_full);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.WarmupIndexRequest
 */
export const WarmupIndexRequest = new WarmupIndexRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WarmupIndexResponse$Type extends MessageType<WarmupIndexResponse> {
    constructor() {
        super("summa.proto.WarmupIndexResponse", [
            { no: 1, name: "elapsed_secs", kind: "scalar", localName: "elapsed_secs", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<WarmupIndexResponse>): WarmupIndexResponse {
        const message = { elapsed_secs: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WarmupIndexResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WarmupIndexResponse): WarmupIndexResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double elapsed_secs */ 1:
                    message.elapsed_secs = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WarmupIndexResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double elapsed_secs = 1; */
        if (message.elapsed_secs !== 0)
            writer.tag(1, WireType.Bit64).double(message.elapsed_secs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.WarmupIndexResponse
 */
export const WarmupIndexResponse = new WarmupIndexResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileEngineConfig$Type extends MessageType<FileEngineConfig> {
    constructor() {
        super("summa.proto.FileEngineConfig", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FileEngineConfig>): FileEngineConfig {
        const message = { path: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FileEngineConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileEngineConfig): FileEngineConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileEngineConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.FileEngineConfig
 */
export const FileEngineConfig = new FileEngineConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MemoryEngineConfig$Type extends MessageType<MemoryEngineConfig> {
    constructor() {
        super("summa.proto.MemoryEngineConfig", [
            { no: 1, name: "schema", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MemoryEngineConfig>): MemoryEngineConfig {
        const message = { schema: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MemoryEngineConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemoryEngineConfig): MemoryEngineConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string schema */ 1:
                    message.schema = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MemoryEngineConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string schema = 1; */
        if (message.schema !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.schema);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.MemoryEngineConfig
 */
export const MemoryEngineConfig = new MemoryEngineConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CacheConfig$Type extends MessageType<CacheConfig> {
    constructor() {
        super("summa.proto.CacheConfig", [
            { no: 1, name: "cache_size", kind: "scalar", localName: "cache_size", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<CacheConfig>): CacheConfig {
        const message = { cache_size: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CacheConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CacheConfig): CacheConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 cache_size */ 1:
                    message.cache_size = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CacheConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 cache_size = 1; */
        if (message.cache_size !== "0")
            writer.tag(1, WireType.Varint).uint64(message.cache_size);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.CacheConfig
 */
export const CacheConfig = new CacheConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoteEngineConfig$Type extends MessageType<RemoteEngineConfig> {
    constructor() {
        super("summa.proto.RemoteEngineConfig", [
            { no: 1, name: "method", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "url_template", kind: "scalar", localName: "url_template", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "headers_template", kind: "map", localName: "headers_template", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "cache_config", kind: "message", localName: "cache_config", T: () => CacheConfig },
            { no: 5, name: "timeout_ms", kind: "scalar", localName: "timeout_ms", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RemoteEngineConfig>): RemoteEngineConfig {
        const message = { method: "", url_template: "", headers_template: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RemoteEngineConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoteEngineConfig): RemoteEngineConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string method */ 1:
                    message.method = reader.string();
                    break;
                case /* string url_template */ 2:
                    message.url_template = reader.string();
                    break;
                case /* map<string, string> headers_template */ 3:
                    this.binaryReadMap3(message.headers_template, reader, options);
                    break;
                case /* summa.proto.CacheConfig cache_config */ 4:
                    message.cache_config = CacheConfig.internalBinaryRead(reader, reader.uint32(), options, message.cache_config);
                    break;
                case /* optional uint32 timeout_ms */ 5:
                    message.timeout_ms = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: RemoteEngineConfig["headers_template"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof RemoteEngineConfig["headers_template"] | undefined, val: RemoteEngineConfig["headers_template"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field summa.proto.RemoteEngineConfig.headers_template");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: RemoteEngineConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string method = 1; */
        if (message.method !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.method);
        /* string url_template = 2; */
        if (message.url_template !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url_template);
        /* map<string, string> headers_template = 3; */
        for (let k of Object.keys(message.headers_template))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.headers_template[k]).join();
        /* summa.proto.CacheConfig cache_config = 4; */
        if (message.cache_config)
            CacheConfig.internalBinaryWrite(message.cache_config, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 timeout_ms = 5; */
        if (message.timeout_ms !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.timeout_ms);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.RemoteEngineConfig
 */
export const RemoteEngineConfig = new RemoteEngineConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogMergePolicy$Type extends MessageType<LogMergePolicy> {
    constructor() {
        super("summa.proto.LogMergePolicy", [
            { no: 1, name: "is_frozen", kind: "scalar", localName: "is_frozen", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<LogMergePolicy>): LogMergePolicy {
        const message = { is_frozen: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LogMergePolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogMergePolicy): LogMergePolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_frozen */ 1:
                    message.is_frozen = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogMergePolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_frozen = 1; */
        if (message.is_frozen !== false)
            writer.tag(1, WireType.Varint).bool(message.is_frozen);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.LogMergePolicy
 */
export const LogMergePolicy = new LogMergePolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TemporalMergePolicy$Type extends MessageType<TemporalMergePolicy> {
    constructor() {
        super("summa.proto.TemporalMergePolicy", [
            { no: 1, name: "merge_older_then_secs", kind: "scalar", localName: "merge_older_then_secs", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<TemporalMergePolicy>): TemporalMergePolicy {
        const message = { merge_older_then_secs: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TemporalMergePolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TemporalMergePolicy): TemporalMergePolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 merge_older_then_secs */ 1:
                    message.merge_older_then_secs = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TemporalMergePolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 merge_older_then_secs = 1; */
        if (message.merge_older_then_secs !== "0")
            writer.tag(1, WireType.Varint).uint64(message.merge_older_then_secs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.TemporalMergePolicy
 */
export const TemporalMergePolicy = new TemporalMergePolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndexEngineConfig$Type extends MessageType<IndexEngineConfig> {
    constructor() {
        super("summa.proto.IndexEngineConfig", [
            { no: 1, name: "file", kind: "message", oneof: "config", T: () => FileEngineConfig },
            { no: 2, name: "memory", kind: "message", oneof: "config", T: () => MemoryEngineConfig },
            { no: 3, name: "remote", kind: "message", oneof: "config", T: () => RemoteEngineConfig },
            { no: 10, name: "merge_policy", kind: "message", localName: "merge_policy", T: () => MergePolicy },
            { no: 11, name: "query_parser_config", kind: "message", localName: "query_parser_config", T: () => QueryParserConfig }
        ]);
    }
    create(value?: PartialMessage<IndexEngineConfig>): IndexEngineConfig {
        const message = { config: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IndexEngineConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndexEngineConfig): IndexEngineConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* summa.proto.FileEngineConfig file */ 1:
                    message.config = {
                        oneofKind: "file",
                        file: FileEngineConfig.internalBinaryRead(reader, reader.uint32(), options, (message.config as any).file)
                    };
                    break;
                case /* summa.proto.MemoryEngineConfig memory */ 2:
                    message.config = {
                        oneofKind: "memory",
                        memory: MemoryEngineConfig.internalBinaryRead(reader, reader.uint32(), options, (message.config as any).memory)
                    };
                    break;
                case /* summa.proto.RemoteEngineConfig remote */ 3:
                    message.config = {
                        oneofKind: "remote",
                        remote: RemoteEngineConfig.internalBinaryRead(reader, reader.uint32(), options, (message.config as any).remote)
                    };
                    break;
                case /* summa.proto.MergePolicy merge_policy */ 10:
                    message.merge_policy = MergePolicy.internalBinaryRead(reader, reader.uint32(), options, message.merge_policy);
                    break;
                case /* summa.proto.QueryParserConfig query_parser_config */ 11:
                    message.query_parser_config = QueryParserConfig.internalBinaryRead(reader, reader.uint32(), options, message.query_parser_config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IndexEngineConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* summa.proto.FileEngineConfig file = 1; */
        if (message.config.oneofKind === "file")
            FileEngineConfig.internalBinaryWrite(message.config.file, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.MemoryEngineConfig memory = 2; */
        if (message.config.oneofKind === "memory")
            MemoryEngineConfig.internalBinaryWrite(message.config.memory, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.RemoteEngineConfig remote = 3; */
        if (message.config.oneofKind === "remote")
            RemoteEngineConfig.internalBinaryWrite(message.config.remote, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.MergePolicy merge_policy = 10; */
        if (message.merge_policy)
            MergePolicy.internalBinaryWrite(message.merge_policy, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* summa.proto.QueryParserConfig query_parser_config = 11; */
        if (message.query_parser_config)
            QueryParserConfig.internalBinaryWrite(message.query_parser_config, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.IndexEngineConfig
 */
export const IndexEngineConfig = new IndexEngineConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndexDescription$Type extends MessageType<IndexDescription> {
    constructor() {
        super("summa.proto.IndexDescription", [
            { no: 1, name: "index_name", kind: "scalar", localName: "index_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "index_aliases", kind: "scalar", localName: "index_aliases", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "index_engine", kind: "message", localName: "index_engine", T: () => IndexEngineConfig },
            { no: 4, name: "num_docs", kind: "scalar", localName: "num_docs", T: 4 /*ScalarType.UINT64*/ },
            { no: 5, name: "compression", kind: "enum", T: () => ["summa.proto.Compression", Compression] },
            { no: 6, name: "index_attributes", kind: "message", localName: "index_attributes", T: () => IndexAttributes }
        ]);
    }
    create(value?: PartialMessage<IndexDescription>): IndexDescription {
        const message = { index_name: "", index_aliases: [], num_docs: "0", compression: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IndexDescription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndexDescription): IndexDescription {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string index_name */ 1:
                    message.index_name = reader.string();
                    break;
                case /* repeated string index_aliases */ 2:
                    message.index_aliases.push(reader.string());
                    break;
                case /* summa.proto.IndexEngineConfig index_engine */ 3:
                    message.index_engine = IndexEngineConfig.internalBinaryRead(reader, reader.uint32(), options, message.index_engine);
                    break;
                case /* uint64 num_docs */ 4:
                    message.num_docs = reader.uint64().toString();
                    break;
                case /* summa.proto.Compression compression */ 5:
                    message.compression = reader.int32();
                    break;
                case /* summa.proto.IndexAttributes index_attributes */ 6:
                    message.index_attributes = IndexAttributes.internalBinaryRead(reader, reader.uint32(), options, message.index_attributes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IndexDescription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string index_name = 1; */
        if (message.index_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.index_name);
        /* repeated string index_aliases = 2; */
        for (let i = 0; i < message.index_aliases.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.index_aliases[i]);
        /* summa.proto.IndexEngineConfig index_engine = 3; */
        if (message.index_engine)
            IndexEngineConfig.internalBinaryWrite(message.index_engine, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint64 num_docs = 4; */
        if (message.num_docs !== "0")
            writer.tag(4, WireType.Varint).uint64(message.num_docs);
        /* summa.proto.Compression compression = 5; */
        if (message.compression !== 0)
            writer.tag(5, WireType.Varint).int32(message.compression);
        /* summa.proto.IndexAttributes index_attributes = 6; */
        if (message.index_attributes)
            IndexAttributes.internalBinaryWrite(message.index_attributes, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.IndexDescription
 */
export const IndexDescription = new IndexDescription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndexDocumentOperation$Type extends MessageType<IndexDocumentOperation> {
    constructor() {
        super("summa.proto.IndexDocumentOperation", [
            { no: 1, name: "document", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<IndexDocumentOperation>): IndexDocumentOperation {
        const message = { document: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IndexDocumentOperation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndexDocumentOperation): IndexDocumentOperation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes document */ 1:
                    message.document = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IndexDocumentOperation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes document = 1; */
        if (message.document.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.document);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.IndexDocumentOperation
 */
export const IndexDocumentOperation = new IndexDocumentOperation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndexOperation$Type extends MessageType<IndexOperation> {
    constructor() {
        super("summa.proto.IndexOperation", [
            { no: 2, name: "index_document", kind: "message", localName: "index_document", oneof: "operation", T: () => IndexDocumentOperation }
        ]);
    }
    create(value?: PartialMessage<IndexOperation>): IndexOperation {
        const message = { operation: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IndexOperation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndexOperation): IndexOperation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* summa.proto.IndexDocumentOperation index_document */ 2:
                    message.operation = {
                        oneofKind: "index_document",
                        index_document: IndexDocumentOperation.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).index_document)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IndexOperation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* summa.proto.IndexDocumentOperation index_document = 2; */
        if (message.operation.oneofKind === "index_document")
            IndexDocumentOperation.internalBinaryWrite(message.operation.index_document, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.IndexOperation
 */
export const IndexOperation = new IndexOperation$Type();
/**
 * @generated ServiceType for protobuf service summa.proto.IndexApi
 */
export const IndexApi = new ServiceType("summa.proto.IndexApi", [
    { name: "attach_index", options: {}, I: AttachIndexRequest, O: AttachIndexResponse },
    { name: "commit_index", options: {}, I: CommitIndexRequest, O: CommitIndexResponse },
    { name: "copy_documents", options: {}, I: CopyDocumentsRequest, O: CopyDocumentsResponse },
    { name: "create_index", options: {}, I: CreateIndexRequest, O: CreateIndexResponse },
    { name: "copy_index", options: {}, I: CopyIndexRequest, O: CopyIndexResponse },
    { name: "delete_documents", options: {}, I: DeleteDocumentsRequest, O: DeleteDocumentsResponse },
    { name: "delete_index", options: {}, I: DeleteIndexRequest, O: DeleteIndexResponse },
    { name: "documents", serverStreaming: true, options: {}, I: DocumentsRequest, O: DocumentsResponse },
    { name: "get_indices_aliases", options: {}, I: GetIndicesAliasesRequest, O: GetIndicesAliasesResponse },
    { name: "get_index", options: {}, I: GetIndexRequest, O: GetIndexResponse },
    { name: "get_indices", options: {}, I: GetIndicesRequest, O: GetIndicesResponse },
    { name: "index_document_stream", clientStreaming: true, options: {}, I: IndexDocumentStreamRequest, O: IndexDocumentStreamResponse },
    { name: "index_document", options: {}, I: IndexDocumentRequest, O: IndexDocumentResponse },
    { name: "merge_segments", options: {}, I: MergeSegmentsRequest, O: MergeSegmentsResponse },
    { name: "set_index_alias", options: {}, I: SetIndexAliasRequest, O: SetIndexAliasResponse },
    { name: "vacuum_index", options: {}, I: VacuumIndexRequest, O: VacuumIndexResponse },
    { name: "warmup_index", options: {}, I: WarmupIndexRequest, O: WarmupIndexResponse }
]);
