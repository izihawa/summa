// @generated by protobuf-ts 2.9.1 with parameter use_proto_field_name
// @generated from protobuf file "consumer_service.proto" (package "summa.proto", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Request describe how new Consumer should be created
 *
 * @generated from protobuf message summa.proto.CreateConsumerRequest
 */
export interface CreateConsumerRequest {
    /**
     * Kafka boostrap servers
     *
     * @generated from protobuf field: repeated string bootstrap_servers = 1;
     */
    bootstrap_servers: string[];
    /**
     * Kafka group ID
     *
     * @generated from protobuf field: string group_id = 2;
     */
    group_id: string;
    /**
     * Summa `index_name` which will ingest data from Kafka topics
     *
     * @generated from protobuf field: string index_name = 3;
     */
    index_name: string;
    /**
     * Consumer name, used for further referencing consumer in API and configs
     *
     * @generated from protobuf field: string consumer_name = 4;
     */
    consumer_name: string;
    /**
     * List of topics to consume
     *
     * @generated from protobuf field: repeated string topics = 5;
     */
    topics: string[];
}
/**
 * @generated from protobuf message summa.proto.CreateConsumerResponse
 */
export interface CreateConsumerResponse {
    /**
     * @generated from protobuf field: summa.proto.Consumer consumer = 1;
     */
    consumer?: Consumer;
}
/**
 * @generated from protobuf message summa.proto.DeleteConsumerRequest
 */
export interface DeleteConsumerRequest {
    /**
     * @generated from protobuf field: string consumer_name = 1;
     */
    consumer_name: string;
}
/**
 * @generated from protobuf message summa.proto.DeleteConsumerResponse
 */
export interface DeleteConsumerResponse {
    /**
     * @generated from protobuf field: string consumer_name = 2;
     */
    consumer_name: string;
}
/**
 * @generated from protobuf message summa.proto.GetConsumerRequest
 */
export interface GetConsumerRequest {
    /**
     * @generated from protobuf field: string index_name = 1;
     */
    index_name: string;
    /**
     * @generated from protobuf field: string consumer_name = 2;
     */
    consumer_name: string;
}
/**
 * @generated from protobuf message summa.proto.GetConsumerResponse
 */
export interface GetConsumerResponse {
    /**
     * @generated from protobuf field: summa.proto.Consumer consumer = 1;
     */
    consumer?: Consumer;
}
/**
 * @generated from protobuf message summa.proto.GetConsumersRequest
 */
export interface GetConsumersRequest {
}
/**
 * @generated from protobuf message summa.proto.GetConsumersResponse
 */
export interface GetConsumersResponse {
    /**
     * @generated from protobuf field: repeated summa.proto.Consumer consumers = 1;
     */
    consumers: Consumer[];
}
/**
 * Consumer description
 *
 * @generated from protobuf message summa.proto.Consumer
 */
export interface Consumer {
    /**
     * Consumer name
     *
     * @generated from protobuf field: string consumer_name = 1;
     */
    consumer_name: string;
    /**
     * Summa `index_name`
     *
     * @generated from protobuf field: string index_name = 2;
     */
    index_name: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class CreateConsumerRequest$Type extends MessageType<CreateConsumerRequest> {
    constructor() {
        super("summa.proto.CreateConsumerRequest", [
            { no: 1, name: "bootstrap_servers", kind: "scalar", localName: "bootstrap_servers", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "group_id", kind: "scalar", localName: "group_id", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "index_name", kind: "scalar", localName: "index_name", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "consumer_name", kind: "scalar", localName: "consumer_name", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "topics", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateConsumerRequest>): CreateConsumerRequest {
        const message = { bootstrap_servers: [], group_id: "", index_name: "", consumer_name: "", topics: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateConsumerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateConsumerRequest): CreateConsumerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string bootstrap_servers */ 1:
                    message.bootstrap_servers.push(reader.string());
                    break;
                case /* string group_id */ 2:
                    message.group_id = reader.string();
                    break;
                case /* string index_name */ 3:
                    message.index_name = reader.string();
                    break;
                case /* string consumer_name */ 4:
                    message.consumer_name = reader.string();
                    break;
                case /* repeated string topics */ 5:
                    message.topics.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateConsumerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string bootstrap_servers = 1; */
        for (let i = 0; i < message.bootstrap_servers.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.bootstrap_servers[i]);
        /* string group_id = 2; */
        if (message.group_id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.group_id);
        /* string index_name = 3; */
        if (message.index_name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.index_name);
        /* string consumer_name = 4; */
        if (message.consumer_name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.consumer_name);
        /* repeated string topics = 5; */
        for (let i = 0; i < message.topics.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.topics[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.CreateConsumerRequest
 */
export const CreateConsumerRequest = new CreateConsumerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateConsumerResponse$Type extends MessageType<CreateConsumerResponse> {
    constructor() {
        super("summa.proto.CreateConsumerResponse", [
            { no: 1, name: "consumer", kind: "message", T: () => Consumer }
        ]);
    }
    create(value?: PartialMessage<CreateConsumerResponse>): CreateConsumerResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateConsumerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateConsumerResponse): CreateConsumerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* summa.proto.Consumer consumer */ 1:
                    message.consumer = Consumer.internalBinaryRead(reader, reader.uint32(), options, message.consumer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateConsumerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* summa.proto.Consumer consumer = 1; */
        if (message.consumer)
            Consumer.internalBinaryWrite(message.consumer, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.CreateConsumerResponse
 */
export const CreateConsumerResponse = new CreateConsumerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteConsumerRequest$Type extends MessageType<DeleteConsumerRequest> {
    constructor() {
        super("summa.proto.DeleteConsumerRequest", [
            { no: 1, name: "consumer_name", kind: "scalar", localName: "consumer_name", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteConsumerRequest>): DeleteConsumerRequest {
        const message = { consumer_name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteConsumerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteConsumerRequest): DeleteConsumerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string consumer_name */ 1:
                    message.consumer_name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteConsumerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string consumer_name = 1; */
        if (message.consumer_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.consumer_name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.DeleteConsumerRequest
 */
export const DeleteConsumerRequest = new DeleteConsumerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteConsumerResponse$Type extends MessageType<DeleteConsumerResponse> {
    constructor() {
        super("summa.proto.DeleteConsumerResponse", [
            { no: 2, name: "consumer_name", kind: "scalar", localName: "consumer_name", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteConsumerResponse>): DeleteConsumerResponse {
        const message = { consumer_name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteConsumerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteConsumerResponse): DeleteConsumerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string consumer_name */ 2:
                    message.consumer_name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteConsumerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string consumer_name = 2; */
        if (message.consumer_name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.consumer_name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.DeleteConsumerResponse
 */
export const DeleteConsumerResponse = new DeleteConsumerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetConsumerRequest$Type extends MessageType<GetConsumerRequest> {
    constructor() {
        super("summa.proto.GetConsumerRequest", [
            { no: 1, name: "index_name", kind: "scalar", localName: "index_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "consumer_name", kind: "scalar", localName: "consumer_name", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetConsumerRequest>): GetConsumerRequest {
        const message = { index_name: "", consumer_name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetConsumerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetConsumerRequest): GetConsumerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string index_name */ 1:
                    message.index_name = reader.string();
                    break;
                case /* string consumer_name */ 2:
                    message.consumer_name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetConsumerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string index_name = 1; */
        if (message.index_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.index_name);
        /* string consumer_name = 2; */
        if (message.consumer_name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.consumer_name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.GetConsumerRequest
 */
export const GetConsumerRequest = new GetConsumerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetConsumerResponse$Type extends MessageType<GetConsumerResponse> {
    constructor() {
        super("summa.proto.GetConsumerResponse", [
            { no: 1, name: "consumer", kind: "message", T: () => Consumer }
        ]);
    }
    create(value?: PartialMessage<GetConsumerResponse>): GetConsumerResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetConsumerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetConsumerResponse): GetConsumerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* summa.proto.Consumer consumer */ 1:
                    message.consumer = Consumer.internalBinaryRead(reader, reader.uint32(), options, message.consumer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetConsumerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* summa.proto.Consumer consumer = 1; */
        if (message.consumer)
            Consumer.internalBinaryWrite(message.consumer, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.GetConsumerResponse
 */
export const GetConsumerResponse = new GetConsumerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetConsumersRequest$Type extends MessageType<GetConsumersRequest> {
    constructor() {
        super("summa.proto.GetConsumersRequest", []);
    }
    create(value?: PartialMessage<GetConsumersRequest>): GetConsumersRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetConsumersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetConsumersRequest): GetConsumersRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetConsumersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.GetConsumersRequest
 */
export const GetConsumersRequest = new GetConsumersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetConsumersResponse$Type extends MessageType<GetConsumersResponse> {
    constructor() {
        super("summa.proto.GetConsumersResponse", [
            { no: 1, name: "consumers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Consumer }
        ]);
    }
    create(value?: PartialMessage<GetConsumersResponse>): GetConsumersResponse {
        const message = { consumers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetConsumersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetConsumersResponse): GetConsumersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated summa.proto.Consumer consumers */ 1:
                    message.consumers.push(Consumer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetConsumersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated summa.proto.Consumer consumers = 1; */
        for (let i = 0; i < message.consumers.length; i++)
            Consumer.internalBinaryWrite(message.consumers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.GetConsumersResponse
 */
export const GetConsumersResponse = new GetConsumersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Consumer$Type extends MessageType<Consumer> {
    constructor() {
        super("summa.proto.Consumer", [
            { no: 1, name: "consumer_name", kind: "scalar", localName: "consumer_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "index_name", kind: "scalar", localName: "index_name", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Consumer>): Consumer {
        const message = { consumer_name: "", index_name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Consumer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Consumer): Consumer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string consumer_name */ 1:
                    message.consumer_name = reader.string();
                    break;
                case /* string index_name */ 2:
                    message.index_name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Consumer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string consumer_name = 1; */
        if (message.consumer_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.consumer_name);
        /* string index_name = 2; */
        if (message.index_name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.index_name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message summa.proto.Consumer
 */
export const Consumer = new Consumer$Type();
/**
 * @generated ServiceType for protobuf service summa.proto.ConsumerApi
 */
export const ConsumerApi = new ServiceType("summa.proto.ConsumerApi", [
    { name: "create_consumer", options: {}, I: CreateConsumerRequest, O: CreateConsumerResponse },
    { name: "get_consumer", options: {}, I: GetConsumerRequest, O: GetConsumerResponse },
    { name: "get_consumers", options: {}, I: GetConsumersRequest, O: GetConsumersResponse },
    { name: "delete_consumer", options: {}, I: DeleteConsumerRequest, O: DeleteConsumerResponse }
]);
